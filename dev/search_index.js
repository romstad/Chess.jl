var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference-1","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Boards-1","page":"API Reference","title":"Boards","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Board\nstartboard\n@startboard\nfromfen\nfen\npprint(b::Board)\nlichessurl\nlichess(b::Board)\npieceon\nsidetomove\nepsquare\nkingsquare\npieces\npawns\nknights\nbishops\nrooks\nqueens\nkings\nbishoplike\nrooklike\noccupiedsquares\nemptysquares\ncancastlekingside\ncancastlequeenside\nbishopattacks(b::Board, s::Square)\nrookattacks(b::Board, s::Square)\nqueenattacks(b::Board, s::Square)\nisattacked\nattacksto\nattacksfrom\nsee\nlastmove\nischeck\nischeckmate(b::Board)\nisstalemate\nismaterialdraw\nisrule50draw\nisdraw(b::Board)\nisterminal(b::Board)\npinned\ndomove(b::Board, m::Move)\ndomove!(b::Board, m::Move)\ndonullmove(b::Board)\ndonullmove!(b::Board)\nundomove!\ndomoves(b::Board, moves::Vararg{Move})\ndomoves!(b::Board, moves::Vararg{Move})\nMoveList\npush!(list::MoveList, m::Move)\nrecycle!\nmoves\nmovecount\nhaslegalmoves\nperft\ndivide\nflip\nflop\nrotate\ncompress\ndecompress\nSTART_FEN","category":"page"},{"location":"api/#Chess.Board","page":"API Reference","title":"Chess.Board","text":"Board\n\nType representing a chess board.\n\nA chess board is most commonly obtained from a FEN string (using the fromfen() function), from the startboard() function (which returns a board in the usual chess starting position), or by making a move on some other chess board.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.startboard","page":"API Reference","title":"Chess.startboard","text":"startboard()\n\nReturns a Board object with the standard chess initial position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.@startboard","page":"API Reference","title":"Chess.@startboard","text":"@startboard\n\nA macro for initializing a board from the initial position with some moves.\n\nCastling moves must be indicated without a hyphen (i.e. \"OO\" or \"OOO\") in order to satisfy Julia's parser.\n\nExamples\n\njulia> @startboard e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 OO\nBoard (r1bqkb1r/1ppp1ppp/p1n2n2/4p3/B3P3/5N2/PPPP1PPP/RNBQ1RK1 b kq -):\n r  -  b  q  k  b  -  r\n -  p  p  p  -  p  p  p\n p  -  n  -  -  n  -  -\n -  -  -  -  p  -  -  -\n B  -  -  -  P  -  -  -\n -  -  -  -  -  N  -  -\n P  P  P  P  -  P  P  P\n R  N  B  Q  -  R  K  -\n\n\n\n\n\n","category":"macro"},{"location":"api/#Chess.fromfen","page":"API Reference","title":"Chess.fromfen","text":"fromfen(fen::String)\n\nTry to create a Board value from a FEN string.\n\nIf the supplied string doesn't represent a valid board position, this function returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.fen","page":"API Reference","title":"Chess.fen","text":"fen(b::Board)\n\nConvert a board to a FEN string.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pprint-Tuple{Board}","page":"API Reference","title":"Chess.pprint","text":"pprint(b::Board, color = false, highlight = SS_EMPTY, unicode = false)\n\nPretty-print a Board to the standard output.\n\nOn terminals with 24-bit color support, use color = true for a colored board. Use the parameter highlight to include a SquareSet you want to be highlighted.\n\nUse unicode = true for Unicode piece output, if your font and terminal supports it.\n\nExamples\n\njulia> pprint(startboard(), highlight = SquareSet(SQ_D4, SQ_E4, SQ_D5, SQ_E5))\n+---+---+---+---+---+---+---+---+\n| r | n | b | q | k | b | n | r |\n+---+---+---+---+---+---+---+---+\n| p | p | p | p | p | p | p | p |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   | * | * |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   | * | * |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n| P | P | P | P | P | P | P | P |\n+---+---+---+---+---+---+---+---+\n| R | N | B | Q | K | B | N | R |\n+---+---+---+---+---+---+---+---+\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.lichessurl","page":"API Reference","title":"Chess.lichessurl","text":"lichessurl(b::Board)\n\nReturns an URL for opening the board in lichess.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.lichess-Tuple{Board}","page":"API Reference","title":"Chess.lichess","text":"lichess(b::Board)\n\nOpens the board in lichess.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.pieceon","page":"API Reference","title":"Chess.pieceon","text":"pieceon(b::Board, s::Square)\npieceon(b::Board, f::SquareFile, r::SquareRank)\npieceon(b::Board, s::String)\n\nFind the piece on the given square of the board.\n\nExamples\n\njulia> b = startboard();\n\njulia> pieceon(b, SQ_E1)\nPIECE_WK\n\njulia> pieceon(b, FILE_B, RANK_8)\nPIECE_BN\n\njulia> pieceon(b, SQ_B5)\nEMPTY\n\njulia> pieceon(b, \"d8\")\nPIECE_BQ\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.sidetomove","page":"API Reference","title":"Chess.sidetomove","text":"sidetomove(b::Board)\n\nThe current side to move, WHITE or BLACK.\n\nExamples\n\njulia> b = startboard();\n\njulia> b2 = domove(b, \"e4\");\n\njulia> sidetomove(b)\nWHITE\n\njulia> sidetomove(b2)\nBLACK\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.epsquare","page":"API Reference","title":"Chess.epsquare","text":"epsquare(b::Board)\n\nThe square on which an en passant capture is possible, or SQ_NONE.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.kingsquare","page":"API Reference","title":"Chess.kingsquare","text":"kingsquare(b::Board, c::PieceColor)\n\nThe square of the king for the given side.\n\nExamples\n\njulia> b = startboard();\n\njulia> kingsquare(b, WHITE)\nSQ_E1\n\njulia> kingsquare(b, BLACK)\nSQ_E8\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pieces","page":"API Reference","title":"Chess.pieces","text":"pieces(b::Board, c::PieceColor)\npieces(b::Board, t::PieceType)\npieces(b::Board, c::PieceColor, t::PieceType)\npieces(b::Board, p::Piece)\n\nObtain the set of squares containing various kinds of pieces.\n\nExamples\n\njulia> b = startboard();\n\njulia> pieces(b, WHITE) == SS_RANK_1 ∪ SS_RANK_2\ntrue\n\njulia> pieces(b, ROOK) == SquareSet(SQ_A1, SQ_H1, SQ_A8, SQ_H8)\ntrue\n\njulia> pieces(b, BLACK, PAWN) == SS_RANK_7\ntrue\n\njulia> pieces(b, PIECE_WB)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  #  -  -  #  -  -\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawns","page":"API Reference","title":"Chess.pawns","text":"pawns(b::Board)\n\nThe set of squares containing pawns of either color.\n\nExamples\n\njulia> b = startboard();\n\njulia> pawns(b) == SS_RANK_2 ∪ SS_RANK_7\ntrue\n\n\n\n\n\npawns(b::Board, c::PieceColor)\n\nThe set of squares containing pawns of the given color.\n\nExamples\n\njulia> b = startboard();\n\njulia> pawns(b, WHITE) == SS_RANK_2\ntrue\n\njulia> pawns(b, BLACK) == SS_RANK_7\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.knights","page":"API Reference","title":"Chess.knights","text":"knights(b::Board)\n\nThe set of squares containing knights of either color.\n\nExamples\n\njulia> b = startboard();\n\njulia> knights(b) == SquareSet(SQ_B1, SQ_G1, SQ_B8, SQ_G8)\ntrue\n\n\n\n\n\nknights(b::Board, c::PieceColor)\n\nThe set of squares containing knights of the given color.\n\nExamples\n\njulia> b = startboard();\n\njulia> knights(b, WHITE) == SquareSet(SQ_B1, SQ_G1)\ntrue\n\njulia> knights(b, BLACK) == SquareSet(SQ_B8, SQ_G8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.bishops","page":"API Reference","title":"Chess.bishops","text":"bishops(b::Board)\n\nThe set of squares containing bishops of either color.\n\nExamples\n\njulia> b = startboard();\n\njulia> bishops(b) == SquareSet(SQ_C1, SQ_F1, SQ_C8, SQ_F8)\ntrue\n\n\n\n\n\nbishops(b::Board, c::PieceColor)\n\nThe set of squares containing bishops of the given color.\n\nExamples\n\njulia> b = startboard();\n\njulia> bishops(b, WHITE) == SquareSet(SQ_C1, SQ_F1)\ntrue\n\njulia> bishops(b, BLACK) == SquareSet(SQ_C8, SQ_F8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.rooks","page":"API Reference","title":"Chess.rooks","text":"rooks(b::Board)\n\nThe set of squares containing rooks of either color.\n\nExamples\n\njulia> b = startboard();\n\njulia> rooks(b) == SquareSet(SQ_A1, SQ_H1, SQ_A8, SQ_H8)\ntrue\n\n\n\n\n\nrooks(b::Board, c::PieceColor)\n\nThe set of squares containing rooks of the given color.\n\nExamples\n\njulia> b = startboard();\n\njulia> rooks(b, WHITE) == SquareSet(SQ_A1, SQ_H1)\ntrue\n\njulia> rooks(b, BLACK) == SquareSet(SQ_A8, SQ_H8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.queens","page":"API Reference","title":"Chess.queens","text":"queens(b::Board)\n\nThe set of squares containing queens of either color.\n\nExamples\n\njulia> b = startboard();\n\njulia> queens(b) == SquareSet(SQ_D1, SQ_D8)\ntrue\n\n\n\n\n\nqueens(b::Board, c::PieceColor)\n\nThe set of squares containing queens of the given color.\n\nExamples\n\njulia> b = startboard();\n\njulia> queens(b, WHITE) == SquareSet(SQ_D1)\ntrue\n\njulia> queens(b, BLACK) == SquareSet(SQ_D8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.kings","page":"API Reference","title":"Chess.kings","text":"kings(b::Board)\n\nThe set of squares containing kings of either color.\n\nExamples\n\njulia> b = startboard();\n\njulia> kings(b) == SquareSet(SQ_E1, SQ_E8)\ntrue\n\n\n\n\n\nkings(b::Board, c::PieceColor)\n\nThe set of squares containing kings of the given color.\n\nUnless something is very wrong, this set should always contain exactly one square.\n\nExamples\n\njulia> b = startboard();\n\njulia> kings(b, WHITE) == SquareSet(SQ_E1)\ntrue\n\njulia> kings(b, BLACK) == SquareSet(SQ_E8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.bishoplike","page":"API Reference","title":"Chess.bishoplike","text":"bishoplike(b::Board)\n\nThe set of squares containing bishoplike pieces of either color.\n\nThe bishoplike pieces are the pieces that can move like a bishop, i.e. bishops and queens.\n\nExamples\n\njulia> b = startboard();\n\njulia> bishoplike(b) == SquareSet(SQ_C1, SQ_D1, SQ_F1, SQ_C8, SQ_D8, SQ_F8)\ntrue\n\n\n\n\n\nbishoplike(b::Board, c::PieceColor)\n\nThe set of squares containing bishoplike pieces of the given color.\n\nThe bishoplike pieces are the pieces that can move like a bishop, i.e. bishops and queens.\n\nExamples\n\njulia> b = startboard();\n\njulia> bishoplike(b, WHITE) == SquareSet(SQ_C1, SQ_D1, SQ_F1)\ntrue\n\njulia> bishoplike(b, BLACK) == SquareSet(SQ_C8, SQ_D8, SQ_F8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.rooklike","page":"API Reference","title":"Chess.rooklike","text":"rooklike(b::Board)\n\nThe set of squares containing rooklike pieces of either color.\n\nThe rooklike pieces are the pieces that can move like a rook, i.e. rooks and queens.\n\nExamples\n\njulia> b = startboard();\n\njulia> rooklike(b) == SquareSet(SQ_A1, SQ_D1, SQ_H1, SQ_A8, SQ_D8, SQ_H8)\ntrue\n\n\n\n\n\nrooklike(b::Board, c::PieceColor)\n\nThe set of squares containing rooklike pieces of the given color.\n\nThe rooklike pieces are the pieces that can move like a rook, i.e. rooks and queens.\n\nExamples\n\njulia> b = startboard();\n\njulia> rooklike(b, WHITE) == SquareSet(SQ_A1, SQ_D1, SQ_H1)\ntrue\n\njulia> rooklike(b, BLACK) == SquareSet(SQ_A8, SQ_D8, SQ_H8)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.occupiedsquares","page":"API Reference","title":"Chess.occupiedsquares","text":"occupiedsquares(b::Board)\n\nThe set of all occupied squares on the board.\n\nExamples\n\njulia> b = startboard();\n\njulia> occupiedsquares(b) == pieces(b, WHITE) ∪ pieces(b, BLACK)\ntrue\n\njulia> isempty(emptysquares(b) ∩ occupiedsquares(b))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.emptysquares","page":"API Reference","title":"Chess.emptysquares","text":"emptysquares(b::Board)\n\nThe set of all empty squares on the board.\n\nExamples\n\njulia> emptysquares(startboard())\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.cancastlekingside","page":"API Reference","title":"Chess.cancastlekingside","text":"cancastlekingside(b::Board, c::PieceColor)\n\nDetermine whether the given side still has the right to castle kingside.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.cancastlequeenside","page":"API Reference","title":"Chess.cancastlequeenside","text":"cancastlequeenside(b::Board, c::PieceColor)\n\nDetermine whether the given side still has the right to castle queenside.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.bishopattacks-Tuple{Board, Square}","page":"API Reference","title":"Chess.bishopattacks","text":"bishopattacks(b::Board, s::Square)\n\nThe set of squares a bishop on square s would attack on this board.\n\nBoth empty squares and squares occupied by enemy or friendly pieces are included in the set.\n\nExamples\n\njulia> b = fromfen(\"5k2/8/4q3/8/2B5/8/4P3/3K4 w - -\");\n\njulia> pprint(b, highlight=bishopattacks(b, SQ_C4))\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   | k |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n| * |   |   |   |*q*|   |   |   |\n+---+---+---+---+---+---+---+---+\n|   | * |   | * |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | B |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   | * |   | * |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n| * |   |   |   |*P*|   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   | K |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n5k2/8/4q3/8/2B5/8/4P3/3K4 w - -\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.rookattacks-Tuple{Board, Square}","page":"API Reference","title":"Chess.rookattacks","text":"rookattacks(b::Board, s::Square)\n\nThe set of squares a rook on square s would attack on this board.\n\nBoth empty squares and squares occupied by enemy or friendly pieces are included in the set.\n\nExamples\n\njulia> b = fromfen(\"2r2k2/8/8/8/2R3P1/8/4P3/3K4 w - -\");\n\njulia> pprint(b, highlight=rookattacks(b, SQ_C4))\n+---+---+---+---+---+---+---+---+\n|   |   |*r*|   |   | k |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n| * | * | R | * | * | * |*P*|   |\n+---+---+---+---+---+---+---+---+\n|   |   | * |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * |   | P |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * | K |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n2r2k2/8/8/8/2R3P1/8/4P3/3K4 w - -\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.queenattacks-Tuple{Board, Square}","page":"API Reference","title":"Chess.queenattacks","text":"queenattacks(b::Board, s::Square)\n\nThe set of squares a queen on square s would attack on this board.\n\nBoth empty squares and squares occupied by enemy or friendly pieces are included in the set.\n\nExamples\n\njulia> b = fromfen(\"2r2k2/8/8/8/2Q3P1/8/4P3/3K4 w - -\");\n\njulia> pprint(b, highlight=queenattacks(b, SQ_C4))\n+---+---+---+---+---+---+---+---+\n|   |   |*r*|   |   | k | * |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * |   |   | * |   |   |\n+---+---+---+---+---+---+---+---+\n| * |   | * |   | * |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   | * | * | * |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n| * | * | Q | * | * | * |*P*|   |\n+---+---+---+---+---+---+---+---+\n|   | * | * | * |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n| * |   | * |   |*P*|   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * | K |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n2r2k2/8/8/8/2Q3P1/8/4P3/3K4 w - -\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.isattacked","page":"API Reference","title":"Chess.isattacked","text":"isattacked(b::Board, s::Square, side::PieceColor)\n\nDetermine whether the given square is attacked by the given side.\n\nExamples\n\njulia> b = startboard();\n\njulia> isattacked(b, SQ_F3, WHITE)\ntrue\n\njulia> isattacked(b, SQ_F3, BLACK)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.attacksto","page":"API Reference","title":"Chess.attacksto","text":"attacksto(b::Board, s::Square)\n\nThe set of squares containing pieces of either color which attack square s.\n\nExamples\n\njulia> b = fromfen(\"r1bqkbnr/pppp1ppp/2n5/4p3/3PP3/5N2/PPP2PPP/RNBQKB1R b KQkq - 0 3\");\n\njulia> pprint(b, highlight=attacksto(b, SQ_D4))\n+---+---+---+---+---+---+---+---+\n| r |   | b | q | k | b | n | r |\n+---+---+---+---+---+---+---+---+\n| p | p | p | p |   | p | p | p |\n+---+---+---+---+---+---+---+---+\n|   |   |*n*|   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |*p*|   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   | P | P |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |*N*|   |   |\n+---+---+---+---+---+---+---+---+\n| P | P | P |   |   | P | P | P |\n+---+---+---+---+---+---+---+---+\n| R | N | B |*Q*| K | B |   | R |\n+---+---+---+---+---+---+---+---+\nr1bqkbnr/pppp1ppp/2n5/4p3/3PP3/5N2/PPP2PPP/RNBQKB1R b KQkq -\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.attacksfrom","page":"API Reference","title":"Chess.attacksfrom","text":"attacksfrom(b::Board, s::Square)\n\nThe set of squares attacked by the piece on s.\n\nBoth empty squares, squares containing enemy pieces, and squares containing friendly pieces are included.\n\nExamples\n\njulia> b = fromfen(\"r1bqkbnr/pppp1ppp/2n5/4p3/3PP3/5N2/PPP2PPP/RNBQKB1R b KQkq - 0 3\");\n\njulia> pprint(b, highlight=attacksfrom(b, SQ_F1))\n+---+---+---+---+---+---+---+---+\n| r |   | b | q | k | b | n | r |\n+---+---+---+---+---+---+---+---+\n| p | p | p | p |   | p | p | p |\n+---+---+---+---+---+---+---+---+\n| * |   | n |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   | * |   |   | p |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | * | P | P |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   | * |   | N |   |   |\n+---+---+---+---+---+---+---+---+\n| P | P | P |   | * | P |*P*| P |\n+---+---+---+---+---+---+---+---+\n| R | N | B | Q | K | B |   | R |\n+---+---+---+---+---+---+---+---+\nr1bqkbnr/pppp1ppp/2n5/4p3/3PP3/5N2/PPP2PPP/RNBQKB1R b KQkq -\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.see","page":"API Reference","title":"Chess.see","text":"see(b::Board, m::Move)::Int\nsee(b::Board, m::String)::Int\n\nStatic exchange evaluator.\n\nThis function estimates the material gain/loss of a move without doing any search, just looking at the attackers and defenders of the destination square, including X-ray attackers and defenders. It does not consider pins, overloaded pieces, etc., and is therefore only reliable as a very rough guess.\n\nExamples\n\njulia> b = fromfen(\"8/4k3/8/4p3/8/2BK4/8/q7 w - - 0 1\")\nBoard (8/4k3/8/4p3/8/2BK4/8/q7 w - -):\n -  -  -  -  -  -  -  -\n -  -  -  -  k  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  p  -  -  -\n -  -  -  -  -  -  -  -\n -  -  B  K  -  -  -  -\n -  -  -  -  -  -  -  -\n q  -  -  -  -  -  -  -\n\njulia> see(b, \"Bxe5\")\n-2\n\njulia> b = fromfen(\"7q/4k1b1/3p4/4n3/8/2BK1N2/4R3/4R3 w - - 0 1\")\nBoard (7q/4k1b1/3p4/4n3/8/2BK1N2/4R3/4R3 w - -):\n -  -  -  -  -  -  -  q\n -  -  -  -  k  -  b  -\n -  -  -  p  -  -  -  -\n -  -  -  -  n  -  -  -\n -  -  -  -  -  -  -  -\n -  -  B  K  -  N  -  -\n -  -  -  -  R  -  -  -\n -  -  -  -  R  -  -  -\n\njulia> see(b, \"Nxe5\")\n1\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.lastmove","page":"API Reference","title":"Chess.lastmove","text":"lastmove(b::Board)\n\nThe last move that was played to reach this board position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.ischeck","page":"API Reference","title":"Chess.ischeck","text":"ischeck(b::Board)\n\nDetermine whether the current side to move is in check.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.ischeckmate-Tuple{Board}","page":"API Reference","title":"Chess.ischeckmate","text":"ischeckmate(b::Board)::Bool\n\nReturns true if the side to move is checkmated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.isstalemate","page":"API Reference","title":"Chess.isstalemate","text":"isstalemate(b::Board)::Bool\n\nReturns true if the board is a stalemate position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.ismaterialdraw","page":"API Reference","title":"Chess.ismaterialdraw","text":"ismaterialdraw(b::Board)::Bool\n\nReturns true if the position is a draw by material.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isrule50draw","page":"API Reference","title":"Chess.isrule50draw","text":"isrule50draw(b::Board)::Bool\n\nReturns true if the position is drawn by the 50 moves rule.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isdraw-Tuple{Board}","page":"API Reference","title":"Chess.isdraw","text":"isdraw(b::Board)::Bool\n\nReturns true if the position is an immediate draw.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.isterminal-Tuple{Board}","page":"API Reference","title":"Chess.isterminal","text":"isterminal(b::Board)::Bool\n\nReturns true if the game position is terminal, i.e. mate or immediate draw.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.pinned","page":"API Reference","title":"Chess.pinned","text":"pinned(b::Board)\n\nThe set of squares containing pinned pieces for the current side to move.\n\nExamples\n\njulia> b = fromfen(\"2r4b/1kp5/8/2P1Q3/1P6/2K1P2r/8/8 w - -\");\n\njulia> pprint(b, highlight=pinned(b))\n+---+---+---+---+---+---+---+---+\n|   |   | r |   |   |   |   | b |\n+---+---+---+---+---+---+---+---+\n|   | k | p |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | P |   |*Q*|   |   |   |\n+---+---+---+---+---+---+---+---+\n|   | P |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   | K |   |*P*|   |   | r |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n2r4b/1kp5/8/2P1Q3/1P6/2K1P2r/8/8 w - -\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.domove-Tuple{Board, Move}","page":"API Reference","title":"Chess.domove","text":"domove(b::Board, m::Move)\ndomove(b::Board, m::String)\n\nDo the move m on the board b, and return the new board.\n\nThe board b itself is left unchanged, a new board is returned. There is a much faster destructive function domove!() that should be called instead when high performance is required.\n\nIf the supplied move is a string, this function tries to parse the move as a UCI move first, then as a SAN move.\n\nIt's the caller's responsibility to make sure m is a legal move on this board.\n\nExamples\n\njulia> b = startboard();\n\njulia> domove(b, \"Nf3\")\nBoard (rnbqkbnr/pppppppp/8/8/8/5N2/PPPPPPPP/RNBQKB1R b KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  N  -  -\n P  P  P  P  P  P  P  P\n R  N  B  Q  K  B  -  R\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.domove!-Tuple{Board, Move}","page":"API Reference","title":"Chess.domove!","text":"domove!(b::Board, m::Move)\ndomove!(b::Board, m::String)\n\nDestructively modify the board b by making the move m.\n\nIf the supplied move is a string, this function tries to parse the move as a UCI move first, then as a SAN move.\n\nIt's the caller's responsibility to make sure the move m is legal.\n\nThe function returns a value of type UndoInfo. You'll need this if you want to later call undomove!() to take back the move and get the original position back.\n\nExamples\n\njulia> b = startboard();\n\njulia> domove!(b, \"d4\");\n\njulia> b\nBoard (rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  P  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  -  P  P  P  P\n R  N  B  Q  K  B  N  R\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.donullmove-Tuple{Board}","page":"API Reference","title":"Chess.donullmove","text":"donullmove(b::Board)\n\nReturns an identical board with the side to move switched.\n\nThe board b itself is left unchanged. A new board is returned that is identical in every way except that the side to move is the opposite. In other words, the function has the effect of \"passing\" and giving the other player the chance to move.\n\nNote that this will result in an illegal position if the side to move at b is in check. It's the caller's responsibility to make sure donullmove is not used in that case.\n\nThere is a much faster destructive function donullmove! that should be called instead when high performance is required.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.donullmove!-Tuple{Board}","page":"API Reference","title":"Chess.donullmove!","text":"donullmove!(b::Board)\n\nDestructively modify the board b by swapping the side to move.\n\nThe board is left unchanged except that the side to move is changed. In other words, the function has the effect of \"passing\" and giving the other player the chance to move.\n\nNote that this will result in an illegal position if the side to move at b is in check. It's the caller's responsibility to make sure donullmove is not used in that case.\n\nThe function returns a value of type UndoInfo. You'll need this if you want to later call undomove!() to take back the move and get the original position back.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.undomove!","page":"API Reference","title":"Chess.undomove!","text":"undomove!(b::Board, u::UndoInfo)\n\nUndo a move earlier done by domove!().\n\nThe second parameter is the UndoInfo value returned by the earlier call to domove!().\n\nExamples\n\njulia> b = startboard();\n\njulia> u = domove!(b, \"c4\");\n\njulia> b\nBoard (rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR b KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  P  -  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  -  P  P  P  P  P\n R  N  B  Q  K  B  N  R\n\njulia> undomove!(b, u);\n\njulia> b\nBoard (rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  P  P  P  P  P\n R  N  B  Q  K  B  N  R\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.domoves-Tuple{Board, Vararg{Move, N} where N}","page":"API Reference","title":"Chess.domoves","text":"domoves(b::Board, moves::Vararg{Move})\ndomoves(b::Board, moves::Vararg{String})\n\nReturn the board achieved from a starting board b by making a sequence of moves.\n\nThe input board b is left unchanged.\n\nIf the supplied moves are strings, this function tries to parse the moves as UCI moves first, and as SAN moves if UCI move parsing fails.\n\nIt's the caller's responsibility to make sure all moves are legal. If a plain move is illegal, the consequences are undefined. If a move string cannot be parsed as an unambiguous legal move, the function throws an exception.\n\nThere is also a destructive version of this version, named domoves!\n\nExamples\n\njulia> b = startboard();\n\njulia> domoves(b, \"d4\", \"Nf6\", \"c4\", \"e6\", \"Nc3\", \"Bb4\")\nBoard (rnbqk2r/pppp1ppp/4pn2/8/1bPP4/2N5/PP2PPPP/R1BQKBNR w KQkq -):\n r  n  b  q  k  -  -  r\n p  p  p  p  -  p  p  p\n -  -  -  -  p  n  -  -\n -  -  -  -  -  -  -  -\n -  b  P  P  -  -  -  -\n -  -  N  -  -  -  -  -\n P  P  -  -  P  P  P  P\n R  -  B  Q  K  B  N  R\n\njulia> domoves(b, \"d4\", \"Nf6\", \"c5\")\nERROR: \"Illegal or ambiguous move: c5\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.domoves!-Tuple{Board, Vararg{Move, N} where N}","page":"API Reference","title":"Chess.domoves!","text":"domoves!(b::Board, moves::Vararg{Move})\ndomoves!(b::Board, moves::Vararg{String})\n\nDestructively modify the board b by making a sequence of moves.\n\nIf the supplied moves are strings, this function tries to parse the moves as UCI moves first, and as SAN moves if UCI move parsing fails.\n\nIt's the caller's responsibility to make sure all moves are legal. If a plain move is illegal, the consequences are undefined. If a move string cannot be parsed as an unambiguous legal move, the function throws an exception.\n\nThere is also a non-destructive version of this version, named domoves.\n\nExamples\n\njulia> b = startboard();\n\njulia> domoves!(b, \"e4\", \"c5\", \"Nf3\", \"d6\", \"d4\", \"cxd4\", \"Nxd4\", \"Nf6\", \"Nc3\");\n\njulia> b\nBoard (rnbqkb1r/pp2pppp/3p1n2/8/3NP3/2N5/PPP2PPP/R1BQKB1R b KQkq -):\n r  n  b  q  k  b  -  r\n p  p  -  -  p  p  p  p\n -  -  -  p  -  n  -  -\n -  -  -  -  -  -  -  -\n -  -  -  N  P  -  -  -\n -  -  N  -  -  -  -  -\n P  P  P  -  -  P  P  P\n R  -  B  Q  K  B  -  R\n\njulia> b = startboard();\n\njulia> domoves!(b, \"e4\", \"Qxe4+\")\nERROR: \"Illegal or ambiguous move: Qxe4+\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.MoveList","page":"API Reference","title":"Chess.MoveList","text":"MoveList\n\nAn iterable type containing a a list of moves, as produced by legal move generators.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.push!-Tuple{MoveList, Move}","page":"API Reference","title":"Base.push!","text":"push!(list::MoveList, m::Move)\n\nAdd a new move to the move list.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.recycle!","page":"API Reference","title":"Chess.recycle!","text":"recycle!(list::MoveList)\n\nRecycle the move list in order to re-use for generating new moves.\n\nThis is useful when you want to avoid allocating too much heap memory. If you have a MoveList lying around that you no longer need, consider reusing it instead of creating a new one the next time you need to generate some moves.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.moves","page":"API Reference","title":"Chess.moves","text":"moves(b::Board, list::MoveList)\nmoves(b::Board)\n\nObtain a list of all legal moves from this board.\n\nWhen performance is important, consider using the two-argument method that supplies a pre-allocated move list.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.movecount","page":"API Reference","title":"Chess.movecount","text":"movecount(b::Board)::Int\n\nThe number of legal moves from this board.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.haslegalmoves","page":"API Reference","title":"Chess.haslegalmoves","text":"haslegalmoves(b::Board)::Bool\n\nReturns true if the side to move has at least one legal move.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.perft","page":"API Reference","title":"Chess.perft","text":"perft(b::Board, depth::Int)\n\nDo a perft search to the given depth.\n\nSee https://www.chessprogramming.org/Perft.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.divide","page":"API Reference","title":"Chess.divide","text":"divide(b::Board, depth::Int)\n\nDo a divide search to debug the perft() function.\n\nSee https://www.chessprogramming.org/Perft.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.flip","page":"API Reference","title":"Chess.flip","text":"flip(b::Board)\n\nReturns an identical board, but flipped vertically, and with the opposite side to move.\n\nExamples\n\njulia> b = @startboard d4 Nf6 c4 e6 Nc3 Bb4 e3 OO\nBoard (rnbq1rk1/pppp1ppp/4pn2/8/1bPP4/2N1P3/PP3PPP/R1BQKBNR w KQ -):\n r  n  b  q  -  r  k  -\n p  p  p  p  -  p  p  p\n -  -  -  -  p  n  -  -\n -  -  -  -  -  -  -  -\n -  b  P  P  -  -  -  -\n -  -  N  -  P  -  -  -\n P  P  -  -  -  P  P  P\n R  -  B  Q  K  B  N  R\n\njulia> flip(b)\nBoard (r1bqkbnr/pp3ppp/2n1p3/1Bpp4/8/4PN2/PPPP1PPP/RNBQ1RK1 b kq -):\n r  -  b  q  k  b  n  r\n p  p  -  -  -  p  p  p\n -  -  n  -  p  -  -  -\n -  B  p  p  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  P  N  -  -\n P  P  P  P  -  P  P  P\n R  N  B  Q  -  R  K  -\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.flop","page":"API Reference","title":"Chess.flop","text":"flop(b::Board)\n\nReturns an identical board, but flipped horizontally.\n\nAll castling rights will be deleted.\n\nExamples\n\njulia> b = @startboard d4 Nf6 c4 e6 Nc3 Bb4 e3 OO\nBoard (rnbq1rk1/pppp1ppp/4pn2/8/1bPP4/2N1P3/PP3PPP/R1BQKBNR w KQ -):\n r  n  b  q  -  r  k  -\n p  p  p  p  -  p  p  p\n -  -  -  -  p  n  -  -\n -  -  -  -  -  -  -  -\n -  b  P  P  -  -  -  -\n -  -  N  -  P  -  -  -\n P  P  -  -  -  P  P  P\n R  -  B  Q  K  B  N  R\n\njulia> flop(b)\nBoard (1kr1qbnr/ppp1pppp/2np4/8/4PPb1/3P1N2/PPP3PP/RNBKQB1R w - -):\n -  k  r  -  q  b  n  r\n p  p  p  -  p  p  p  p\n -  -  n  p  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  P  P  b  -\n -  -  -  P  -  N  -  -\n P  P  P  -  -  -  P  P\n R  N  B  K  Q  B  -  R\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.rotate","page":"API Reference","title":"Chess.rotate","text":"rotate(b::Board)\n\nReturns an identical board, but rotated 180 degrees.\n\nAll castling rights will be deleted.\n\nExamples\n\njulia> b = @startboard d4 Nf6 c4 e6 Nc3 Bb4 e3 OO\nBoard (rnbq1rk1/pppp1ppp/4pn2/8/1bPP4/2N1P3/PP3PPP/R1BQKBNR w KQ -):\n r  n  b  q  -  r  k  -\n p  p  p  p  -  p  p  p\n -  -  -  -  p  n  -  -\n -  -  -  -  -  -  -  -\n -  b  P  P  -  -  -  -\n -  -  N  -  P  -  -  -\n P  P  -  -  -  P  P  P\n R  -  B  Q  K  B  N  R\n\njulia> rotate(b)\nBoard (rnbkqb1r/ppp3pp/3p1n2/4ppB1/8/2NP4/PPP1PPPP/1KR1QBNR b - -):\n r  n  b  k  q  b  -  r\n p  p  p  -  -  -  p  p\n -  -  -  p  -  n  -  -\n -  -  -  -  p  p  B  -\n -  -  -  -  -  -  -  -\n -  -  N  P  -  -  -  -\n P  P  P  -  P  P  P  P\n -  K  R  -  Q  B  N  R\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.compress","page":"API Reference","title":"Chess.compress","text":"compress(b::Board)\n\nCompresses a board into a byte array of maximum 26 bytes.\n\nUse the inverse function decompress to recover a compressed board.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.decompress","page":"API Reference","title":"Chess.decompress","text":"decompress(bytes::Vector{UInt8})\n\nDecompresses a Board previously compressed by the compress function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.START_FEN","page":"API Reference","title":"Chess.START_FEN","text":"START_FEN\n\nThe FEN string of the standard chess opening position.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Games-1","page":"API Reference","title":"Games","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"SimpleGame\nSimpleGame(startboard::Board=startboard())\nSimpleGame(startfen::String)\nGame\nGame()\nGame(startboard::Board)\nGame(startfen::String)\n@simplegame\n@game\nGameHeader\nGameHeaders\nGameNode\nheadervalue\nwhiteplayer\nblackplayer\nsite\ndateplayed\nwhiteelo\nblackelo\nsetheadervalue!\nsetdateplayed!\nboard\nboards\ndomove!(g::SimpleGame, m::Move)\ndomoves!(g::SimpleGame, moves::Vararg{Union{Move, String}})\naddmove!\naddmoves!\nnextmove\nply\nisatbeginning\nisatend\nback!\nforward!\ntobeginning!\ntoend!\ntobeginningofvariation!\ntonode!\nisleaf\ncomment\nprecomment\nnag\naddcomment!\naddprecomment!\naddnag!\nremoveallchildren!\nremovenode!\nadddata!\nremovedata!\ncontinuations\nisdraw(g::SimpleGame)\nischeckmate(g::SimpleGame)\nisterminal(g::SimpleGame)","category":"page"},{"location":"api/#Chess.SimpleGame","page":"API Reference","title":"Chess.SimpleGame","text":"SimpleGame\n\nA type representing a simple game, with no support for comments or variations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.SimpleGame","page":"API Reference","title":"Chess.SimpleGame","text":"SimpleGame(startboard::Board=startboard())\n\nConstructor that creates a SimpleGame from the provided starting position.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.SimpleGame-Tuple{String}","page":"API Reference","title":"Chess.SimpleGame","text":"SimpleGame(startfen::String)\n\nConstructor that creates a SimpleGame from the position given by the provided FEN string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.Game","page":"API Reference","title":"Chess.Game","text":"Game\n\nType representing a chess game, with support for comments and variations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.Game-Tuple{}","page":"API Reference","title":"Chess.Game","text":"Game()\n\nConstructor that creates a new Game from the regular starting position.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.Game-Tuple{Board}","page":"API Reference","title":"Chess.Game","text":"Game(startboard::Board)\n\nConstructor that creates a Game from the provided starting position.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.Game-Tuple{String}","page":"API Reference","title":"Chess.Game","text":"Game(startfen::String)\n\nConstructor that creates a Game from the position given by the provided FEN string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.@simplegame","page":"API Reference","title":"Chess.@simplegame","text":"@simplegame\n\nA macro for initializing a SimpleGame with a number of moves.\n\nCastling moves must be indicated without a hyphen (i.e. \"OO\" or \"OOO\") in order to satisfy Julia's parser.\n\nExamples\n\njulia> @simplegame d4 Nf6 c4 e6 Nc3 Bb4 Qc2 OO\nSimpleGame:\n 1. d4 Nf6 2. c4 e6 3. Nc3 Bb4 4. Qc2 O-O *\n\n\n\n\n\n","category":"macro"},{"location":"api/#Chess.@game","page":"API Reference","title":"Chess.@game","text":"@game\n\nA macro for initializing a Game with a number of moves.\n\nCastling moves must be indicated without a hyphen (i.e. \"OO\" or \"OOO\") in order to satisfy Julia's parser.\n\nExamples\n\njulia> @game d4 Nf6 c4 e6 Nc3 Bb4 Qc2 OO\nGame:\n 1. d4 Nf6 2. c4 e6 3. Nc3 Bb4 4. Qc2 O-O *\n\n\n\n\n\n","category":"macro"},{"location":"api/#Chess.GameHeader","page":"API Reference","title":"Chess.GameHeader","text":"GameHeader\n\nType representing a PGN header tag.\n\nContains name and value slots, both of which are strings.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.GameHeaders","page":"API Reference","title":"Chess.GameHeaders","text":"GameHeaders\n\nType representing the PGN header tags for a game.\n\nContains a slot for each the seven required PGN tags event, site, date, round, white, black and result, all of which are strings. Remaining tags are included in the othertags slot, which contains a vector of GameHeaders.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.GameNode","page":"API Reference","title":"Chess.GameNode","text":"GameNode\n\nType representing a node in a Game.\n\nGame can contain variations, so this type actually represents a node in a tree-like structure.\n\nA GameNode is a mutable struct with the following slots:\n\nparent: The parent GameNode, or nothing if this node is the root of the game.\nboard: The board position at this node.\nchildren: A vector of GameNodes, the children of the current node. The first entry is the main continuation, the remaining entries are alternative variations.\ndata: A Dict{String, Any} used to store information about this node. This is used for comments and numeric annotation glyphs, but can also be used to store other data.\nid: An Int, used to look up this node in a Game, which contains a dictionary mapping ids to GameNodes.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.headervalue","page":"API Reference","title":"Chess.headervalue","text":"headervalue(ghs::GameHeaders, name::String)\nheadervalue(g::SimpleGame, name::String)\nheadervalue(g::Game, name::String)\n\nLooks up the value for the header with the given name.\n\nReturns the value as a String, or nothing if no header with the provided name exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.whiteplayer","page":"API Reference","title":"Chess.whiteplayer","text":"whiteplayer(g::SimpleGame)\nwhiteplayer(g::Game)\n\nThe white player of the game, or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.blackplayer","page":"API Reference","title":"Chess.blackplayer","text":"blackplayer(g::SimpleGame)\nblackplayer(g::Game)\n\nThe black player of the game, or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.site","page":"API Reference","title":"Chess.site","text":"site(g::SimpleGame)\nsite(g::Game)\n\nThe site of the game, or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.dateplayed","page":"API Reference","title":"Chess.dateplayed","text":"dateplayed(g::SimpleGame)::Union{Date, Nothing}\ndateplayed(g::Game)::Union{Date, Nothing}\n\nThe date at which the game was played, or nothing.\n\nThis function makes use of the PGN date tag, trying to behave robustly with sensible defaults when the date is incomplete or incorrectly formatted. It handles both ISO format YYYY-MM-DD dates and PGN format YYYY.MM.DD dates. If either the month or the day is missing, they are replaced with 1. On failure, returns nothing.\n\nExamples\n\njulia> g = Game();\n\njulia> setheadervalue!(g, \"Date\", \"2019.09.20\");\n\njulia> dateplayed(g)\n2019-09-20\n\njulia> setheadervalue!(g, \"Date\", \"2019.09.??\");\n\njulia> dateplayed(g)\n2019-09-01\n\njulia> setheadervalue!(g, \"Date\", \"2019.??.??\");\n\njulia> dateplayed(g)\n2019-01-01\n\njulia> setheadervalue!(g, \"Date\", \"*\");\n\njulia> dateplayed(g) == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.whiteelo","page":"API Reference","title":"Chess.whiteelo","text":"whiteelo(g::SimpeGame)\nwhiteelo(g::Game)\n\nThe Elo of the white player (as given by the \"WhiteElo\" tag), or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.blackelo","page":"API Reference","title":"Chess.blackelo","text":"blackelo(g::SimpeGame)\nblackelo(g::Game)\n\nThe Elo of the black player (as given by the \"BlackElo\" tag), or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.setheadervalue!","page":"API Reference","title":"Chess.setheadervalue!","text":"setheadervalue!(ghs::GameHeaders, name::String, value::String)\nsetheadervalue!(g::SimpleGame, name::String, value::String)\nsetheadervalue!(g::Game, name::String, value::String)\n\nSets a header value, creating the header if it doesn't exist.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.setdateplayed!","page":"API Reference","title":"Chess.setdateplayed!","text":"setdateplayed!(g::SimpleGame, date::Date)\nsetdateplayed!(g::Game, date::Date)\n\nSet the \"Date\" header to the given date, using the standard PGN date format.\n\nExamples\n\njulia> using Dates\n\njulia> g = Game();\n\njulia> setdateplayed!(g, Date(2020, 10, 08));\n\njulia> headervalue(g, \"Date\")\n\"2020.10.08\"\n\njulia> dateplayed(g)\n2020-10-08\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.board","page":"API Reference","title":"Chess.board","text":"board(g::SimpleGame)\nboard(g::Game)\n\nThe board position at the current node in a game.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.boards","page":"API Reference","title":"Chess.boards","text":"boards(g::Game)\nboards(g::SimpleGame)\n\nReturns a vector of all the boards along the main line of the game.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.domove!-Tuple{SimpleGame, Move}","page":"API Reference","title":"Chess.domove!","text":"domove!(g::SimpleGame, m::Move)\ndomove!(g::SimpleGame, m::String)\ndomove!(g::Game, m::Move)\ndomove!(g::Game, m::String)\n\nAdds a new move at the current location in the game move list.\n\nIf the supplied move is a string, this function tries to parse the move as a UCI move first, then as a SAN move.\n\nIf we are at the end of the game, all previous moves are kept, and the new move is added at the end. If we are at any earlier point in the game (because we have taken back one or more moves), the existing game continuation will be deleted and replaced by the new move. All variations starting at this point in the game will also be deleted. If you want to add the new move as a variation instead, make sure you use the Game type instead of SimpleGame, and use addmove! instead of domove!.\n\nThe move m is assumed to be a legal move. It's the caller's responsibility to ensure that this is the case.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.domoves!-Tuple{SimpleGame, Vararg{Union{Move, String}, N} where N}","page":"API Reference","title":"Chess.domoves!","text":"domoves!(g::SimpleGame, moves::Vararg{Union{Move, String}})\ndomoves!(g::Game, moves::Vararg{Union{Move, String}})\n\nAdds a sequence of new moves at the current location in the game move list.\n\nThe moves can be either Move values or strings. In the case of strings, the function tries to parse them first as UCI moves, then as SAN moves.\n\nIf we are at the end of the game, all previous moves are kept, and the new moves are added at the end. If we are at any earlier point in the game (because we have taken back one or more moves), the existing game continuation will be deleted and replaced by the new moves. All variations starting at this point in the game will also be deleted. If you want to add the new moves as a variation instead, make sure you use the Game type instead of SimpleGame, and use addmoves! instead of domoves!.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.addmove!","page":"API Reference","title":"Chess.addmove!","text":"addmove!(g::Game, m::Move)\naddmove!(g::Game, m::String)\n\nAdds the move m to the game g at the current node.\n\nIf the supplied move is a string, this function tries to parse the move as a UCI move first, then as a SAN move.\n\nThe move m must be a legal move from the current node board position. A new game node with the board position after the move has been made is added to the end of the current node's children vector, and that node becomes the current node of the game.\n\nThe move m is assumed to be a legal move. It's the caller's responsibility to ensure that this is the case.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.addmoves!","page":"API Reference","title":"Chess.addmoves!","text":"addmoves!(g::Game, moves::Vararg{Union{Move, String}})\n\nAdds a sequence of moves to the game g at the current node.\n\nThe moves can be either Move values or strings. In the case of strings, the function tries to parse them first as UCI moves, then as SAN moves.\n\nThis function works by calling addmove! repeatedly for all input moves. It's the caller's responsibility to ensure that all moves are legal and unambiguous.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.nextmove","page":"API Reference","title":"Chess.nextmove","text":"nextmove(g::SimpleGame)\nnextmove(g::Game)\n\nThe next move in the game, or nothing if we're at the end of the game.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.ply","page":"API Reference","title":"Chess.ply","text":"ply(g::SimpleGame)\nply(g::Game)\n\nThe ply count of the current node.\n\nReturns 1 for the root node, 2 for children of the root node, etc.\n\nExamples\n\njulia> g = Game();\n\njulia> addmoves!(g, \"d4\", \"Nf6\", \"c4\", \"g6\", \"Nc3\", \"Bg7\");\n\njulia> ply(g)\n7\n\njulia> back!(g);\n\njulia> ply(g)\n6\n\njulia> tobeginning!(g);\n\njulia> ply(g)\n1\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isatbeginning","page":"API Reference","title":"Chess.isatbeginning","text":"isatbeginning(g::SimpleGame)::Bool\nisatbeginning(g::Game)::Bool\n\nReturn true if we are at the beginning of the game, and false otherwise.\n\nWe can be at the beginning of the game either because we haven't yet added any moves to the game, or because we have stepped back to the beginning.\n\nExamples\n\njulia> g = SimpleGame();\n\njulia> isatbeginning(g)\ntrue\n\njulia> domove!(g, \"e4\");\n\njulia> isatbeginning(g)\nfalse\n\njulia> back!(g);\n\njulia> isatbeginning(g)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isatend","page":"API Reference","title":"Chess.isatend","text":"isatend(g::SimpleGame)::Bool\nisatend(g::Game)::Bool\n\nReturn true if we are at the end of the game, and false otherwise.\n\nExamples\n\njulia> g = SimpleGame();\n\njulia> isatend(g)\ntrue\n\njulia> domove!(g, \"Nf3\");\n\njulia> isatend(g)\ntrue\n\njulia> back!(g);\n\njulia> isatend(g)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.back!","page":"API Reference","title":"Chess.back!","text":"back!(g::SimpleGame)\nback!(g::Game)\n\nGo one step back in the game by retracting a move.\n\nIf we're already at the beginning of the game, the game is unchanged.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.forward!","page":"API Reference","title":"Chess.forward!","text":"forward!(g::SimpleGame)\nforward!(g::Game)\nforward!(g::Game, m::Move)\nforward!(g::Game, m::String)\n\nGo one step forward in the game by replaying a previously retracted move.\n\nIf we're already at the end of the game, the game is unchanged. If the current node has multiple children, we always pick the first child (i.e. the main line). If any child other than the first child is desired, supply the move leading to the child node as the second argument. It's the caller's responsibility that the move supplied leads to one of the existing child nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tobeginning!","page":"API Reference","title":"Chess.tobeginning!","text":"tobeginning!(g::SimpleGame)\ntobeginning!(g::Game)\n\nGo back to the beginning of a game by taking back all moves.\n\nIf we're already at the beginning of the game, the game is unchanged.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.toend!","page":"API Reference","title":"Chess.toend!","text":"toend!(g::SimpleGame)\ntoend!(g::Game)\n\nGo forward to the end of a game by replaying all moves, following the main line.\n\nIf we're already at the end of the game, the game is unchanged.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tobeginningofvariation!","page":"API Reference","title":"Chess.tobeginningofvariation!","text":"tobeginningofvariation!(g::Game)\n\nGo to the beginning of the variation containing the current node of the game.\n\nSteps back up the game tree until we reach the point where the first child node (i.e. the main line) is not contained in the current variation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tonode!","page":"API Reference","title":"Chess.tonode!","text":"tonode!(g::Game, id::Int)\n\nGo to the game tree node with the given node id, if it exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isleaf","page":"API Reference","title":"Chess.isleaf","text":"isleaf(n::GameNode)::Bool\n\nTests whether a GameNode is a leaf, i.e. that it has no children.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.comment","page":"API Reference","title":"Chess.comment","text":"comment(n::GameNode)\n\nThe comment after the move leading to this node, or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.precomment","page":"API Reference","title":"Chess.precomment","text":"precomment(n::GameNode)\n\nThe comment before the move leading to this node, or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.nag","page":"API Reference","title":"Chess.nag","text":"nag(n::GameNode)\n\nThe numeric annotation glyph for the move leading to this node, or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.addcomment!","page":"API Reference","title":"Chess.addcomment!","text":"addcomment!(g::Game, comment::String)\n\nAdds a comment to the current game node.\n\nIn PGN and other text ouput formats, the comment is printed after the move leading to the node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.addprecomment!","page":"API Reference","title":"Chess.addprecomment!","text":"addprecomment!(g::Game, comment::String)\n\nAdds a pre-comment to the current game node.\n\nIn PGN and other text ouput formats, the comment is printed before the move leading to the node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.addnag!","page":"API Reference","title":"Chess.addnag!","text":"addnag!(g::Game, nag::Int)\n\nAdds a Numeric Annotation Glyph (NAG) to the current game node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.removeallchildren!","page":"API Reference","title":"Chess.removeallchildren!","text":"removeallchildren!(g::Game, node::GameNode = g.node)\n\nRecursively remove all children of the given node in the game.\n\nIf no node is supplied, removes the children of the current node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.removenode!","page":"API Reference","title":"Chess.removenode!","text":"removenode!(g::Game, node::GameNode = g.node)\n\nRemove a node (by default, the current node) in a Game, and go to the parent node.\n\nAll children of the node are also recursively deleted.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.adddata!","page":"API Reference","title":"Chess.adddata!","text":"adddata!(n::GameNode, key::String, value)\n\nAdd a piece of data to the given node's data dictionary.\n\nThis is a low-level function that is mainly used to add comments and NAGs, but can also be used to add any type of custom annotation data to a game node.\n\n\n\n\n\nadddata!(g::Game, key::String, value)\n\nAdd a piece of data to the current game node's data dictionary.\n\nThis is a low-level function that is mainly used to add comments and NAGs, but can also be used to add any type of custom annotation data to a game node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.removedata!","page":"API Reference","title":"Chess.removedata!","text":"removedata!(n::GameNode, key::String)\n\nRemove a piece of data from the game node's data dictionary.\n\nThis is a low-level function that is mainly used to delete comments and NAGs.\n\n\n\n\n\nremovedata!(n::GameNode, key::String)\n\nRemove a piece of data from the current game node's data dictionary.\n\nThis is a low-level function that is mainly used to delete comments and NAGs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.continuations","page":"API Reference","title":"Chess.continuations","text":"continuations(n::GameNode)::Vector{Move}\ncontinuations(g::Game)::Vector{Move}\n\nAll moves at this node in the game tree.\n\nOne move for each child node of the current node. The first element is the main line.\n\nExamples\n\njulia> g = Game();\n\njulia> addmoves!(g, \"e4\", \"e5\");\n\njulia> back!(g);\n\njulia> addmove!(g, \"c5\");\n\njulia> back!(g);\n\njulia> continuations(g)\n2-element Array{Move,1}:\n Move(e7e5)\n Move(c7c5)\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isdraw-Tuple{SimpleGame}","page":"API Reference","title":"Chess.isdraw","text":"isdraw(g::SimpleGame)\nisdraw(g::Game)\n\nChecks whether the current game position is drawn.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.ischeckmate-Tuple{SimpleGame}","page":"API Reference","title":"Chess.ischeckmate","text":"ischeckmate(g::SimpleGame)\nischeckmate(g::Game)\n\nChecks whether the current game position is a checkmate.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.isterminal-Tuple{SimpleGame}","page":"API Reference","title":"Chess.isterminal","text":"isterminal(g::SimpleGame)\nisterminal(g::Game)\n\nChecks whether the current game position is terminal, i.e. mate or drawn.\n\n\n\n\n\n","category":"method"},{"location":"api/#Opening-Books-1","page":"API Reference","title":"Opening Books","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"BookEntry\ncreatebook\nwritebooktofile\npurgebook\nfindbookentries\npickbookmove\nprintbookentries","category":"page"},{"location":"api/#Chess.Book.BookEntry","page":"API Reference","title":"Chess.Book.BookEntry","text":"BookEntry\n\nA struct representing an opening book entry.\n\nBook entries contain the following slots:\n\nkey: The hash key of the board position this book entry represents.\nmove: The move played, encoded as an Int32. In order to get the actual Move value representing the move stored in a book entry e, you should do Move(e.move).\nelo: The highest Elo rating of a player who played this move.\noppelo: The highest Elo of the opponent in a game where this move was played.\nwins: The number of times the player who played this move won the game.\ndraws: The number of times the player who played this move drew the game.\nlosses: The number of times the player who played this move lost the game.\nfirstyear: The year this move was first played.\nlastyear: The year this move was last played.\nscore: The score of this move, used to obtain a probability distribution when picking a book move for a position. The score is computed based on the W/L/D stats for the move, the ratings of the players who have played it, and on its popularity in more recent games.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.Book.createbook","page":"API Reference","title":"Chess.Book.createbook","text":"createbook(pgnfiles::Vararg{String};\n           scorewhitewin = 8.0,\n           scorewhitedraw = 4.0,\n           scorewhiteloss = 1.0,\n           scoreblackwin = 8.0,\n           scoreblackdraw = 5.0,\n           scoreblackloss = 1.0,\n           scoreunknown = 0.0,\n           highelofactor = 6.0,\n           yearlydecay = 0.85,\n           maxply = 60,\n           minelo = 0,\n           maxelo = 10_000,\n           maxgames = nothing,\n           maxentries = nothing,\n)\n\nCreates an opening book tree from one or more PGN files.\n\nThe opening tree is stored in RAM. You will probably want to save it to disk using writebooktofile afterwards, for instance like this:\n\njulia> bk = createbook(\"my-pgn-file.pgn\");\n\njulia> writebooktofile(bk, \"my-book.obk\")\n\nThe createbook function takes a number of optional named parameters that can be used to control what moves are included in the opening tree, and the scoring of the moves (which is used to produce move probabilities when picking a move using pickbookmove). These are:\n\nscorewhitewin: The base score for all white moves in a game won by white.\nscorewhitedraw: The base score for all white moves in a drawn game.\nscorewhiteloss: The base score for all black moves in a game won by black.\nscoreblackwin: The base score for all black moves in a game won by black.\nscoreblackdraw: The base score for all black moves in a drawn game.\nscoreblackloss: The base score for all black moves in a game won by white.\nscoreunknown: The base score for all moves in a game with an unknown result.\nhighelofactor: Score multiplier for moves played by a player with high rating. The base score is multiplied by max(1.0, 0.01 * highelofactor * (2300 - elo))\nyearlydecay: Controls exponential yearly reduction of scores. If a game was played n years ago, all scores are multiplied by n^yearlydecay.\nmaxply: Maximum depth of the opening tree. If maxply equals 60 (the default), no moves after move 30 are included in the opening tree.\nminelo: Minimum Elo for book moves. Moves played by players below this number are not included in the opening tree.\nmaxelo: Maximum Elo for book moves. Moves played by players above this number are not included in the opening tree.\nmaxgames: Maximum number of games to include. If no value is supplied, all games in the input PGNs will be used.\nmaxentries: Maximum number of book entries to include. If no value is supplied, all entries will be included.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.Book.writebooktofile","page":"API Reference","title":"Chess.Book.writebooktofile","text":"writebooktofile(entries::Vector{BookEntry}, filename::String,\n                compact = false)\n\nWrites a book (as created by createbookfile) to a binary file.\n\nIf the optional parameter compact is true, the book is written in a more compact format that does not include W/L/D counts, Elo numbers and years.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.Book.purgebook","page":"API Reference","title":"Chess.Book.purgebook","text":"purgebook(infilename::String, outfilename::String;\n          minscore = 0, mingamecount = 5, compact = false)\n\nCreates a smaller version of an opening book file by removing unimportant lines.\n\nBook moves with score lower than minscore or which have been played in fewer than mingamecount games are not included in the output file.\n\nIf the optional parameter compact is true, the output file is written in a more compact format that does not include W/L/D counts, Elo numbers and years.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.Book.findbookentries","page":"API Reference","title":"Chess.Book.findbookentries","text":"findbookentries(b::Board, bookfile = nothing)\nfindbookentries(key::UInt64, bookfile = nothing)\n\nReturns all book entries for the given board or key.\n\nIf bookfile is nothing, use the default built-in opening book.\n\nThe return value is a (possibly empty) Vector{BookEntry}, sorted by descending scores.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.Book.pickbookmove","page":"API Reference","title":"Chess.Book.pickbookmove","text":"pickbookmove(\n    b::Board;\n    bookfile = nothing,\n    minscore = 0,\n    mingamecount = 1\n)\n\nPicks a book move for the board b, returning nothing when out of book.\n\nIf bookfile is nothing, uses the built-in default book.\n\nThe move is selected with probabilities given by the score slots in the BookEntry objects. The minscore and mingamecount parameters can be used to exclude moves with low score or low play counts.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.Book.printbookentries","page":"API Reference","title":"Chess.Book.printbookentries","text":"printbookentries(b::Board, bookfile = nothing)\n\nPretty-print the book entries for the provided board.\n\nIf bookfile is nothing, use the default built-in opening book.\n\nThe output columns have the following meanings:\n\nmove: The move.\nprob: Probability that this move will be played when calling pickbookmove.\nscore: Percentage score of this move in the games used to produce this book file.\nwon: Number of games won with this move.\ndrawn: Number of games drawn with this move.\nlost: Number of games lost with this move.\nelo: Maximum Elo of players that played this move.\noelo: Maximum Elo of opponents against which this move was played.\nfirst: The first year this move was played.\nlast: The last year this move was played.\n\nExamples\n\njulia> printbookentries(@startboard d4 Nf6 c4 e6 Nc3)\nmove     prob   score     won   drawn    lost    elo oelo  first last\nBb4    71.92%  48.18%   32327   35691   36120   3936 3936   1854 2020\nd5     20.82%  40.46%    4481    6545    8137   3796 3796   1880 2020\nc5      4.20%  43.13%    1560    1192    2247   3794 3851   1922 2020\nb6      2.16%  34.51%     217     170     488   2652 2762   1902 2020\nBe7     0.51%  27.47%      28      33     101   2585 2640   1911 2020\nc6      0.20%  36.05%      13       5      25   2448 2670   1932 2020\ng6      0.12%  31.94%       9       5      22   2289 2405   1943 2020\nNc6     0.06%  33.33%       6      10      17   3809 3809   1938 2020\n\n\n\n\n\n","category":"function"},{"location":"api/#PGN-Files-1","page":"API Reference","title":"PGN Files","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"PGNReader\nPGNReader(io::IO)\nreadgame\ngamefromstring\ngametopgn\ngamesinfile\ngotonextgame!","category":"page"},{"location":"api/#Chess.PGN.PGNReader","page":"API Reference","title":"Chess.PGN.PGNReader","text":"PGNReader\n\nA type for reading PGN data from a stream.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.PGN.PGNReader-Tuple{IO}","page":"API Reference","title":"Chess.PGN.PGNReader","text":"PGNReader(io::IO)\n\nInitializes a PGNReader from an IO object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.PGN.readgame","page":"API Reference","title":"Chess.PGN.readgame","text":"readgame(p::PGNReader; annotations=false)\n\nAttempts to parse a PGN game and use it to create a Game or a SimpleGame.\n\nIf the optional parameter annotations is true, the return value will be a Game containing all comments, variations and numeric annotation glyphs in the PGN. Otherwise, it will be a SimpleGame with only the game moves.\n\nThis function assumes that the PGNReader is pointed at the beginning of a game. If you are not sure this is the case, call gotonextgame! on the PGNReader first.\n\nIf parsing fails or the notation contains illegal or ambiguous moves, the function raises a PGNException.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.PGN.gamefromstring","page":"API Reference","title":"Chess.PGN.gamefromstring","text":"gamefromstring(s::String; annotations=false)\n\nAttempts to create a Game or SimpleGame object from the provided PGN string.\n\nIf the optional parameter annotations is true, the return value will be a Game containing all comments, variations and numeric annotation glyphs in the PGN. Otherwise, it will be a SimpleGame with only the game moves.\n\nIf the string does not parse as valid PGN, or if the notation contains illegal or ambiguous moves, the function raises a PGNException\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.PGN.gametopgn","page":"API Reference","title":"Chess.PGN.gametopgn","text":"gametopgn(g)::String\n\nExports a Game or a SimpleGame to a PGN string.\n\nLimitations\n\nThe movetext section is written in a single long line, with no line breaks.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.PGN.gamesinfile","page":"API Reference","title":"Chess.PGN.gamesinfile","text":"gamesinfile(filename::String; annotations=false, skip=0)\n\nCreates a Channel of Game/SimpleGame objects read from the PGN file with the provided file name.\n\nIf the optional parameter annotations is true, the return value will be a channel of Game objects containing all comments, variations and numeric annotation glyphs in the PGN. Otherwise, it will consist of SimpleGame objects with only the game moves.\n\nThe optional parameter skip makes the function skip the first skip games of the file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.PGN.gotonextgame!","page":"API Reference","title":"Chess.PGN.gotonextgame!","text":"gotonextgame!(p::PGNReader)::Bool\n\nTries to go to the next game, returns true on success.\n\n\n\n\n\n","category":"function"},{"location":"api/#UCI-Chess-Engines-1","page":"API Reference","title":"UCI Chess Engines","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Engine\nrunengine\nnewgame\nquit\nsetoption\nsendisready\nsendcommand\nsetboard\nsearch\nmpvsearch\nBestMoveInfo\nparsebestmove\nSearchInfo\nparsesearchinfo\ntouci\nScore\nBoundType\nOption\nOptionType\nOptionValue","category":"page"},{"location":"api/#Chess.UCI.Engine","page":"API Reference","title":"Chess.UCI.Engine","text":"Engine\n\nType representing a UCI chess engine.\n\nThis is a struct with the following slots:\n\nname: The engine name, as provided by the engine in response to the uci command.\nauthor: The engine author name, as provided by the engine in response to the uci command.\noptions: The UCI options for this engine. This is a dictionary mapping option names (Strings) to options (instances of the Option type).\nio: A Base.Process object used to communicate with the engine.\n\nEngines are created by calling the runengine function, which takes a pathname for an UCI engine as input, runs the engine, and returns an Engine object.\n\nExamples\n\nThe below is a typical interaction with a UCI engine. The example assumes that you have a UCI engine with the file name stockfish somewhere in your PATH.\n\njulia> sf = runengine(\"stockfish\");\n\njulia> setoption(sf, \"Hash\", 128)\n\njulia> setboard(sf, fromfen(\"1kbr3r/pp6/8/P1n2ppq/2N3n1/R3Q1P1/3B1P2/2R2BK1 w - -\"))\n\njulia> search(sf, \"go depth 18\", infoaction=println)\ninfo depth 1 seldepth 1 multipv 1 score cp -842 nodes 88 nps 88000 tbhits 0 time 1 pv f1g2 g4e3 d2e3\ninfo depth 2 seldepth 2 multipv 1 score cp -842 nodes 207 nps 103500 tbhits 0 time 2 pv f1g2 g4e3\ninfo depth 3 seldepth 3 multipv 1 score cp -844 nodes 270 nps 135000 tbhits 0 time 2 pv f1g2 g4e3 d2e3 d8d1 c1d1 h5d1 g2f1\ninfo depth 4 seldepth 5 multipv 1 score cp -844 nodes 367 nps 183500 tbhits 0 time 2 pv f1g2 g4e3 d2e3 d8d1 c1d1\ninfo depth 5 seldepth 7 multipv 1 score cp -953 nodes 866 nps 433000 tbhits 0 time 2 pv f1g2 h5h2 g1f1 g4e3 d2e3 c5d3 e3g5\ninfo depth 6 seldepth 8 multipv 1 score cp -1060 nodes 1507 nps 753500 tbhits 0 time 2 pv f1g2 g4e3 d2e3 c5d3 e3d2 d3c1\ninfo depth 7 seldepth 11 multipv 1 score cp -876 nodes 1995 nps 665000 tbhits 0 time 3 pv f1g2 g4e3\ninfo depth 8 seldepth 10 multipv 1 score cp -882 nodes 2771 nps 923666 tbhits 0 time 3 pv f1g2 g4e3 d2e3 c8e6 e3c5 d8d1 c1d1 h5d1 g2f1 e6c4\ninfo depth 9 seldepth 15 multipv 1 score cp -1068 nodes 12059 nps 1339888 tbhits 0 time 9 pv f1g2 g4e3 a3e3 c8e6 e3e6 c5e6 d2e1 d8d1 c1d1 h5d1\ninfo depth 10 seldepth 15 multipv 1 score cp -1050 nodes 17558 nps 1463166 tbhits 0 time 12 pv f1g2 g4e3 a3e3 c8e6 g1f1 h5g4 e3e6 c5e6 c4e3 g4a4 d2c3\ninfo depth 11 seldepth 17 multipv 1 score cp -1013 nodes 23543 nps 1569533 tbhits 0 time 15 pv f1g2 g4e3 a3e3 c8e6 g1f1 h5g4 e3e6 c5e6 c4e3 g4a4 d2c3\ninfo depth 12 seldepth 20 multipv 1 score cp -995 nodes 48497 nps 1672310 tbhits 0 time 29 pv f1g2 g4e3 a3e3 c8e6 g1f1 c5e4 d2e1 d8c8 g3g4 h5g4 c4e5 g4h4 c1c8 h8c8\ninfo depth 13 seldepth 29 multipv 1 score cp -1116 nodes 205726 nps 1959295 tbhits 0 time 105 pv f1g2 g4e3 f2e3 c5e4 a3a2 h5h2 g1f1 e4g3 f1f2 g3e4 f2f1 e4d2 c4d2 h2g3 d2f3 d8d3 f1g1 d3e3 f3d4 e3e8 a2e2\ninfo depth 14 seldepth 28 multipv 1 score cp -148 nodes 247247 nps 1993927 tbhits 0 time 124 pv e3f4 g5f4 d2f4 b8a8 c4b6 a7b6 a5b6 c5a6\ninfo depth 15 seldepth 16 multipv 1 score cp 120 nodes 248911 nps 1991288 tbhits 0 time 125 pv e3f4 g5f4 d2f4 g4e5 f4e5 d8d6 e5d6 b8a8 f1g2 c8e6 d6c5\ninfo depth 16 seldepth 24 multipv 1 score cp 1117 nodes 251829 nps 1982905 tbhits 0 time 127 pv e3f4 g4e5 f4e5 d8d6 e5d6 b8a8 f1g2 h5h2 g1f1 c5e4 g2e4 f5e4 d2g5 c8h3 f1e2\ninfo depth 17 seldepth 22 multipv 1 score cp 1500 nodes 258707 nps 1990053 tbhits 0 time 130 pv e3f4 g4e5 f4e5 d8d6 e5d6 b8a8 f1g2 h5h2 g1f1 c5e4 g2e4 h2h3 e4g2\ninfo depth 18 seldepth 22 multipv 1 score mate 11 nodes 281736 nps 1984056 tbhits 0 time 142 pv e3f4 g5f4 d2f4 g4e5 f4e5 d8d6 e5d6 b8a8 c4b6 a7b6 a5b6 c5a6 c1c8 h8c8\nBestMoveInfo (best=e3f4, ponder=g5f4)\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.runengine","page":"API Reference","title":"Chess.UCI.runengine","text":"function runengine(path::String)::Engine\n\nRuns the engine at the specified path, returning an Engine.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.newgame","page":"API Reference","title":"Chess.UCI.newgame","text":"newgame(e::Engine)\n\nInstructs the engine that a new game is about to begin.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.quit","page":"API Reference","title":"Chess.UCI.quit","text":"function quit(e::Engine)\n\nSends the UCI engine e the \"quit\" command.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.setoption","page":"API Reference","title":"Chess.UCI.setoption","text":"function setoption(e::Engine, name::String, value::OptionValue = nothing)\n\nSets the UCI option named name to the new value value.\n\nThrows an error if the engine e does not have an option with the provided name, or if the value is incompatible with the type of the option.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.sendisready","page":"API Reference","title":"Chess.UCI.sendisready","text":"sendisready(e::Engine)::Bool\n\nSends the engine e an \"isready\" command and waits for the \"readyok\" response.\n\nReturns true on success, false on failure (i.e. if the engine replies with anything other than \"readyok\").\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.sendcommand","page":"API Reference","title":"Chess.UCI.sendcommand","text":"sendcommand(e::Engine, cmd::String)\n\nSends the UCI command cmd to the engine e.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.setboard","page":"API Reference","title":"Chess.UCI.setboard","text":"setboard(e::Engine, b::Board)\nsetboard(e::Engine, g::SimpleGame)\nsetboard(e::Engine, g::Game)\n\nSet the engine's current board position to the given board/game state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.search","page":"API Reference","title":"Chess.UCI.search","text":"function search(e::Engine, gocmd::String; infoaction = nothing)\n\nTells a UCI engine to start searching.\n\nThe parameter gocmd is the actual command you want to send to the engine; e.g. \"go movetime 10000\" or \"go infinite\". The named parameter infoaction is a function accepting the output of the engine's \"info\" commands and doing something with the output. Usually, it will be some function making internal use of parsesearchinfo().\n\nThe return value is of type BestMoveInfo.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.mpvsearch","page":"API Reference","title":"Chess.UCI.mpvsearch","text":"mpvsearch(game, engine; nodes, depth, pvs)::Vector{SearchInfo}\n\nPerforms a multi-PV search and returns the result as a vector of SearchInfo.\n\nParameters:\n\ngame: A Game, a SimpleGame or a Board.\nengine: An Engine.\nnodes: A named parameter instructing the engine to search to the desired tree size.\ndepth: A named parameter instructing the engine to search to the given depth.\npvs: The number of desired lines. Analysis for the pvs best moves is returned. If pvs is greater than the number of legal moves, analysis for all legal moves is returned.\n\nAt least one of nodes and depth must be supplied. If both are supplied, the function will use depth and ignore nodes.\n\nThe function returns a vector of SearchInfo values, one for each of the pvs best moves.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.BestMoveInfo","page":"API Reference","title":"Chess.UCI.BestMoveInfo","text":"BestMoveInfo\n\nA struct representing the contents of a UCI engine's bestmove output.\n\nContains the following slots:\n\nbestmove: The Move returned by the engine as the best move.\nponder: The engine's expected reply to the best move, a Move or nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.parsebestmove","page":"API Reference","title":"Chess.UCI.parsebestmove","text":"parsebestmove(line::String)::BestMoveInfo\n\nParses a bestmove line printed by a UCI engine to a BestMoveInfo object.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.SearchInfo","page":"API Reference","title":"Chess.UCI.SearchInfo","text":"SearchInfo\n\nA struct representing the contents of a UCI engine's info output.\n\nContains the following slots, all of which can be nothing for a given line of search output:\n\ndepth: The current search depth.\nseldepth: The current selective search depth.\ntime: The time spent searching so far, in milliseconds.\nnodes: The number of nodes searched so far.\npv: The main line, as a vector of Move values.\nmultipv: The multipv index of the line currently printed.\nscore: The score, a value of type Score.\ncurrmove: The move currently searched, a value of type Move.\ncurrmovenumber: The index of the move currently searched in the move list.\nhashfull: A number in the range 0–100, indicating the transposition table saturation percentage.\nnps: Nodes/second count.\ntbhits: Number of tablebase hits.\ncpuload: CPU load percentage.\nstring: An arbitrary string sent by the engine.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.parsesearchinfo","page":"API Reference","title":"Chess.UCI.parsesearchinfo","text":"parsesearchinfo(line::String)::SearchInfo\n\nParses an info line printed by a UCI engine to a SearchInfo object.\n\nSee the documentation for SearchInfo for information about how to inspect and use the return value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.touci","page":"API Reference","title":"Chess.UCI.touci","text":"touci(b::Board)\ntouci(g::SimpleGame)\ntouci(g::Game)\n\nCreate a UCI string representation of a board or a game.\n\nExamples\n\njulia> touci(startboard())\n\"position fen rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -\"\n\njulia> sg = SimpleGame(); domove!(sg, \"e4\"); domove!(sg, \"c5\"); domove!(sg, \"Nf3\");\n\njulia> touci(sg)\n\"position fen rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - moves e2e4 c7c5 g1f3\"\n\njulia> g = Game(); domove!(g, \"d4\"); domove!(g, \"Nf6\"); domove!(g, \"c4\");\n\njulia> touci(g)\n\"position fen rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - moves d2d4 g8f6 c2c4\"\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.UCI.Score","page":"API Reference","title":"Chess.UCI.Score","text":"Score\n\nA struct type representing a score returned by a UCI engine.\n\nThe struct has the following slots:\n\nvalue: An Int representing the score value.\nismate: A Bool that tells whether this is a mate score.\nbound: A BoundType, indicating whether this score is a lower bound, an upper bound, or an exact value.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.BoundType","page":"API Reference","title":"Chess.UCI.BoundType","text":"BoundType\n\nAn enum type representing the score bound types lower, upper and exact.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.Option","page":"API Reference","title":"Chess.UCI.Option","text":"Option\n\nType representing a UCI option. This is a mutable struct with the following slots:\n\nname: A String, the name of the option, as provided by the engine.\ntype: An OptionType, the type of the option, as provided by the engine.\ndefaultValue: An OptionValue, as provided by the engine.\nvalue: An OptionValue, the current value of the option.\nmin: The minimum value of this option. Only used for options of type spin.\nmax: The maximum value of this option. Only used for options of type spin.\ncombovals: Vector of the possible values for this option. Only used for options of type Combo.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.OptionType","page":"API Reference","title":"Chess.UCI.OptionType","text":"OptionType\n\nType representing an UCI option type. This is an enum with values corresponding to the option types defined in the UCI protocol: check, spin, combo, button and string.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.UCI.OptionValue","page":"API Reference","title":"Chess.UCI.OptionValue","text":"OptionValue\n\nType representing the value of a UCI option. This is a union type containing the types Nothing (for options of type button), Bool (for options of type check, Int (for options of type spin) and String (for options of type combo or string).)\n\n\n\n\n\n","category":"constant"},{"location":"api/#Pieces,-Piece-Types-and-Piece-Colors-1","page":"API Reference","title":"Pieces, Piece Types and Piece Colors","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Piece\nPiece(c::PieceColor, t::PieceType)\nPieceColor\nPieceType\npcolor\nptype\ncoloropp\nisslider\ncolorfromchar\npiecetypefromchar\npiecefromchar\ntochar(c::PieceColor)\ntochar(t::PieceType, uppercase = false)\ntochar(p::Piece)","category":"page"},{"location":"api/#Chess.Piece","page":"API Reference","title":"Chess.Piece","text":"Piece\n\nType representing a chess piece.\n\nThe possible values are PIECE_WP, PIECE_WN, PIECE_WB, PIECE_WR, PIECE_WQ, PIECE_WK, PIECE_BP, PIECE_BN, PIECE_BB, PIECE_BR, PIECE_BQ, PIECE_BK and EMPTY. The reason for the existence of the value EMPTY is that we represent a chess board as an array of pieces, and we need a value to indicate an empty square on the board.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.Piece-Tuple{PieceColor, PieceType}","page":"API Reference","title":"Chess.Piece","text":"Piece(c::PieceColor, t::PieceType)\n\nConstruct a piece with the given color and type.\n\nExamples\n\njulia> Piece(BLACK, QUEEN)\nPIECE_BQ\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.PieceColor","page":"API Reference","title":"Chess.PieceColor","text":"PieceColor\n\nType representing the color of a chess piece.\n\nThe possible values are WHITE, BLACK and COLOR_NONE. The reason for the existence of the value COLOR_NONE is that we represent a chess board as an array of pieces, and we need a special Piece value EMPTY to indicate an empty square on the board. The color of the EMPTY piece is COLOR_NONE.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.PieceType","page":"API Reference","title":"Chess.PieceType","text":"PieceType\n\nType representing the type of a chess piece.\n\nThis is essentially a piece without color. The possible values are PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING and PIECE_TYPE_NONE. The reason for the existence of the value PIECE_TYPE_NONE is that we represent a chess board as an array of pieces, and we need a special Piece value EMPTY to indicate an empty square on the board. The type of the EMPTY piece is PIECE_TYPE_NONE\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.pcolor","page":"API Reference","title":"Chess.pcolor","text":"pcolor(p::Piece)\n\nFind the color of a Piece.\n\nExamples\n\njulia> pcolor(PIECE_WB)\nWHITE\n\njulia> pcolor(EMPTY)\nCOLOR_NONE\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.ptype","page":"API Reference","title":"Chess.ptype","text":"ptype(p::Piece)\n\nFind the type of a Piece.\n\nExamples\n\njulia> ptype(PIECE_BQ)\nQUEEN\n\njulia> ptype(EMPTY)\nPIECE_TYPE_NONE\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.coloropp","page":"API Reference","title":"Chess.coloropp","text":"coloropp(c::PieceColor)\n\nReturns the opposite of a color.\n\nExamples\n\njulia> coloropp(WHITE) == BLACK\ntrue\n\njulia> coloropp(BLACK) == WHITE\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.isslider","page":"API Reference","title":"Chess.isslider","text":"isslider(t::PieceType)\nisslider(p::Piece)\n\nDetermine whether a piece is a sliding piece.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.colorfromchar","page":"API Reference","title":"Chess.colorfromchar","text":"colorfromchar(c::Char)\n\nTries to convert a character to a PieceColor.\n\nThe return value is a Union{PieceColor, Nothing}. If the input character is one of the four characters 'w', 'b', 'W', 'B', the function returns the obvious corresponding color (WHITE or BLACK). For all other input characters, the function returns nothing.\n\nExamples\n\njulia> colorfromchar('w') == WHITE\ntrue\n\njulia> colorfromchar('B') == BLACK\ntrue\n\njulia> colorfromchar('x') == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.piecetypefromchar","page":"API Reference","title":"Chess.piecetypefromchar","text":"piecetypefromchar(c::Chars)\n\nTries to convert a character to a PieceType.\n\nThe return value is a Union{PieceType, Nothing}. If the input character is a valid upper- or lowercase English piece letter (PNBRQK), the function returns the corresponding piece type. For all other input characters, the function returns nothing.\n\nExamples\n\njulia> piecetypefromchar('n') == KNIGHT\ntrue\n\njulia> piecetypefromchar('B') == BISHOP\ntrue\n\njulia> piecetypefromchar('a') == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.piecefromchar","page":"API Reference","title":"Chess.piecefromchar","text":"piecefromchar(ch::Char)\n\nTries to convert a character to a Piece.\n\nThe return value is a Union{Piece, Nothing}. If the input character is a valid English piece letter, the corresponding piece is returned. If the piece letter is uppercase, the piece is white. If the piece letter is lowercase, the piece is black.\n\nIf the input value is not a valid English piece letter, the function returns nothing.\n\nExamples\n\njulia> piecefromchar('Q')\nPIECE_WQ\n\njulia> piecefromchar('n')\nPIECE_BN\n\njulia> piecefromchar('-') == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tochar-Tuple{PieceColor}","page":"API Reference","title":"Chess.tochar","text":"tochar(c::PieceColor)\n\nConverts a color to a character.\n\nExamples\n\njulia> tochar(WHITE)\n'w': ASCII/Unicode U+0077 (category Ll: Letter, lowercase)\n\njulia> tochar(BLACK)\n'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n\njulia> tochar(COLOR_NONE)\n'?': ASCII/Unicode U+003f (category Po: Punctuation, other)\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.tochar","page":"API Reference","title":"Chess.tochar","text":"tochar(t::PieceType, uppercase = false)\n\nConverts a PieceType value to a character.\n\nA valid piece type value is converted to its standard English algebraic notation piece letter. Any invalid piece type value is converted to a '?' character. The optional parameter uppercase controls whether the character is an upper- or lower-case letter.\n\nExamples\n\njulia> tochar(PAWN)\n'p': ASCII/Unicode U+0070 (category Ll: Letter, lowercase)\n\njulia> tochar(ROOK, true)\n'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n\njulia> tochar(PIECE_TYPE_NONE)\n'?': ASCII/Unicode U+003f (category Po: Punctuation, other)\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tochar-Tuple{Piece}","page":"API Reference","title":"Chess.tochar","text":"tochar(p::Piece)\n\nConverts a piece to a character.\n\nExamples\n\njulia> tochar(PIECE_WN)\n'N': ASCII/Unicode U+004e (category Lu: Letter, uppercase)\n\njulia> tochar(PIECE_BK)\n'k': ASCII/Unicode U+006b (category Ll: Letter, lowercase)\n\njulia> tochar(EMPTY)\n'?': ASCII/Unicode U+003f (category Po: Punctuation, other)\n\n\n\n\n\n","category":"method"},{"location":"api/#Squares-1","page":"API Reference","title":"Squares","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Square\nSquare(f::SquareFile, r::SquareRank)\nSquareFile\nSquareRank\nSquareDelta\nfile\nrank\ndistance(s1::Square, s2::Square)\ndistance(f1::SquareFile, f2::SquareFile)\ndistance(r1::SquareRank, r2::SquareRank)\nfilefromchar\nrankfromchar\ntochar(f::SquareFile)\ntochar(r::SquareRank)\nsquarefromstring\ntostring(s::Square)","category":"page"},{"location":"api/#Chess.Square","page":"API Reference","title":"Chess.Square","text":"Square\n\nType representing a square on a chess board.\n\nA Square can be constructed either with an Int (with the convention a8=1, a7=2, ..., a1=8, b8=9, b7=10, ..., h1=64) or with a SquareFile and a SquareRank. There are also constants SQ_A1, ..., SQ_H8 for all 64 squares on the board.\n\nExamples\n\njulia> Square(FILE_G, RANK_6)\nSQ_G6\n\njulia> Square(8)\nSQ_A1\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.Square-Tuple{SquareFile, SquareRank}","page":"API Reference","title":"Chess.Square","text":"Square(f::SquareFile, r::SquareRank)\n\nConstruct a square with the given file and rank.\n\nExamples\n\njulia> Square(FILE_D, RANK_5)\nSQ_D5\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.SquareFile","page":"API Reference","title":"Chess.SquareFile","text":"SquareFile\n\nType representing the file of a square on a chess board.\n\nUsually, a SquareFile is obtained either by calling the function file() on a Square or through one of the constants FILE_A, FILE_B, ..., FILE_H.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.SquareRank","page":"API Reference","title":"Chess.SquareRank","text":"SquareRank\n\nType representing the rank of a square on a chess board.\n\nUsually, a SquareRank is obtained either by calling the function rank() on a Square or through one of the constants RANK_1, RANK_2, ..., RANK_8.\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.SquareDelta","page":"API Reference","title":"Chess.SquareDelta","text":"SquareDelta\n\nA type representing the delta or vector between two squares.\n\nA SquareDelta value is usually obtained either through one of the constants DELTA_N, DELTA_S, DELTA_E, DELTA_W, DELTA_NW, DELTA_NE, DELTA_SW, DELTA_SE, or by subtracting two square values.\n\nIt is possible to add or subtract two SquareDeltas, to multiply a SquareDelta by an integer scalar, or to add or subtract a SquareDelta to a Square.\n\nExamples\n\njulia> DELTA_N + DELTA_W == DELTA_NW\ntrue\n\njulia> SQ_D3 - SQ_C3 == DELTA_E\ntrue\n\njulia> SQ_G8 - 3 * DELTA_N\nSQ_G5\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.file","page":"API Reference","title":"Chess.file","text":"file(s::Square)\n\nCompute the file of the square s.\n\nExamples\n\njulia> file(SQ_C4)\nFILE_C\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.rank","page":"API Reference","title":"Chess.rank","text":"rank(s::Square)\n\nCompute the rank of the square s.\n\nExamples\n\njulia> rank(SQ_C4)\nRANK_4\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.distance-Tuple{Square, Square}","page":"API Reference","title":"Chess.distance","text":"distance(s1::Square, s2::Square)\n\nThe distance between two squares, counted by number of king moves.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.distance-Tuple{SquareFile, SquareFile}","page":"API Reference","title":"Chess.distance","text":"distance(f1::SquareFile, f2::SquareFile)\n\nThe horizontal distance between two files.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.distance-Tuple{SquareRank, SquareRank}","page":"API Reference","title":"Chess.distance","text":"distance(r1::SquareRank, r2::SquareRank)\n\nThe vertical distance between two ranks.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.filefromchar","page":"API Reference","title":"Chess.filefromchar","text":"filefromchar(c::Char)\n\nTries to convert a character to a file.\n\nThe return value is a Union{SquareFile, Nothing}. The nothing is returned in case the character does not represent a valid file.\n\nExamples\n\njulia> filefromchar('c')\nFILE_C\n\njulia> filefromchar('2') == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.rankfromchar","page":"API Reference","title":"Chess.rankfromchar","text":"rankfromchar(c::Char)\n\nTries to convert a character to a rank.\n\nThe return value is a Union{SquareRank, Nothing}. The nothing is returned in case the character does not represent a valid rank.\n\nExamples\n\njulia> rankfromchar('2')\nRANK_2\n\njulia> rankfromchar('x') == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tochar-Tuple{SquareFile}","page":"API Reference","title":"Chess.tochar","text":"tochar(f::SquareFile)\n\nConverts a SquareFile to a character.\n\nExamples\n\njulia> tochar(FILE_E)\n'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.tochar-Tuple{SquareRank}","page":"API Reference","title":"Chess.tochar","text":"tochar(r::SquareRank)\n\nConverts SquareRank to a character.\n\nExamples\n\njulia> tochar(RANK_3)\n'3': ASCII/Unicode U+0033 (category Nd: Number, decimal digit)\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.squarefromstring","page":"API Reference","title":"Chess.squarefromstring","text":"squarefromstring(s::String)\n\nTries to convert a string to a Square.\n\nThe return value is of type Union{Square, Nothing}.\n\nIf the input string is too short, or if the two first characters do not represent a square in standard algebraic notation, returns nothing. If the first two characters do represent avalid square, that square is returned, even if there are additional characters.\n\nExamples\n\njulia> squarefromstring(\"d6\")\nSQ_D6\n\njulia> squarefromstring(\"xy\") == nothing\ntrue\n\njulia> squarefromstring(\"\") == nothing\ntrue\n\njulia> squarefromstring(\"g1f3\")\nSQ_G1\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.tostring-Tuple{Square}","page":"API Reference","title":"Chess.tostring","text":"tostring(s::Square)\n\nConverts a square to a string in standard algebraic notation. If the square has an invalid value, the returned string is \"??\".\n\nExamples\n\njulia> tostring(SQ_E4)\n\"e4\"\n\njulia> tostring(Square(100))\n\"??\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Moves-1","page":"API Reference","title":"Moves","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Move\nMove(from::Square, to::Square)\nMove(from::Square, to::Square, promotion::PieceType)\nfrom(m::Move)\nto(m::Move)\nispromotion(m::Move)\npromotion(m::Move)\ntostring(m::Move)\nmovefromstring(s::String)\nmovefromsan\nmovetosan\nvariationtosan(board::Board, v::Vector{Move}; startply=1, movenumbers=true)\nvariationtosan(g::SimpleGame, v::Vector{Move}; movenumbers=true)","category":"page"},{"location":"api/#Chess.Move","page":"API Reference","title":"Chess.Move","text":"Move\n\nType representing a chess move.\n\nA Move value is usually obtained by asking a chess board for moves, or by parsing a move string in UCI or SAN format (in the latter case, we also need a board).\n\n\n\n\n\n","category":"type"},{"location":"api/#Chess.Move-Tuple{Square, Square}","page":"API Reference","title":"Chess.Move","text":"Move(from::Square, to::Square)\n\nLow-level constructor for creating a move with the given from and to squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.Move-Tuple{Square, Square, PieceType}","page":"API Reference","title":"Chess.Move","text":"Move(from::Square, to::Square, promotion::PieceType)\n\nLow-level constructor for creating a move with the given from and to squares and promotion piece type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.from-Tuple{Move}","page":"API Reference","title":"Chess.from","text":"from(m::Move)\n\nThe source square of a move.\n\nExamples\n\njulia> Move(SQ_D2, SQ_D4)\nMove(d2d4)\n\njulia> from(Move(SQ_G1, SQ_F3))\nSQ_G1\n\njulia> from(Move(SQ_C7, SQ_C8, QUEEN))\nSQ_C7\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.to-Tuple{Move}","page":"API Reference","title":"Chess.to","text":"to(m::Move)\n\nThe destination square of a move.\n\nExamples\n\njulia> to(Move(SQ_G1, SQ_F3))\nSQ_F3\n\njulia> to(Move(SQ_C7, SQ_C8, QUEEN))\nSQ_C8\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.ispromotion-Tuple{Move}","page":"API Reference","title":"Chess.ispromotion","text":"ispromotion(m::Move)\n\nDetermine whether a move is a promotion move.\n\nExamples\n\njulia> ispromotion(Move(SQ_G1, SQ_F3))\nfalse\n\njulia> ispromotion(Move(SQ_C7, SQ_C8, QUEEN))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.promotion-Tuple{Move}","page":"API Reference","title":"Chess.promotion","text":"promotion(m::Move)\n\nFind the promotion piece type of a move.\n\nUse this function only after first using ispromotion to determine whether the move is a promotion move at all.\n\nExamples\n\njulia> promotion(Move(SQ_C7, SQ_C8, QUEEN))\nQUEEN\n\njulia> promotion(Move(SQ_B2, SQ_B1, KNIGHT))\nKNIGHT\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.tostring-Tuple{Move}","page":"API Reference","title":"Chess.tostring","text":"tostring(m::Move)\n\nConvert a move to a string in UCI notation.\n\nExamples\n\njulia> tostring(Move(SQ_G1, SQ_F3))\n\"g1f3\"\n\njulia> tostring(Move(SQ_E2, SQ_E1, KNIGHT))\n\"e2e1n\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.movefromstring-Tuple{String}","page":"API Reference","title":"Chess.movefromstring","text":"movefromstring(s::String)\n\nConvert a UCI move string to a move.\n\nReturns nothing if the input string is not a valid UCI move.\n\nExamples\n\njulia> movefromstring(\"d2d4\") == Move(SQ_D2, SQ_D4)\ntrue\n\njulia> movefromstring(\"h7h8q\") == Move(SQ_H7, SQ_H8, QUEEN)\ntrue\n\njulia> movefromstring(\"f7f9\") == nothing\ntrue\n\njulia> movefromstring(\"\") == nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.movefromsan","page":"API Reference","title":"Chess.movefromsan","text":"movefromsan((b::Board, san::String))::Union{Move, Nothing}\n\nTries to read a move in Short Algebraic Notation.\n\nReturns nothing if the provided string is an impossible or ambiguous move.\n\nExamples\n\njulia> movefromsan(b, \"Nf3\")\nMove(g1f3)\n\njulia> movefromsan(b, \"???\") == nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.movetosan","page":"API Reference","title":"Chess.movetosan","text":"function movetosan(b::Board, m::Move)\n\nConverts a move to a string in short algebraic notation.\n\nExamples\n\njulia> b = startboard();\n\njulia> movetosan(b, Move(SQ_D2, SQ_D4))\n\"d4\"\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.variationtosan-Tuple{Board, Vector{Move}}","page":"API Reference","title":"Chess.variationtosan","text":"variationtosan(board::Board, v::Vector{Move};\n               startply=1, movenumbers=true)::String\n\nConverts a variation to a string in short algebraic notation.\n\nThe vector of moves v should be a sequence of legal moves from the board position. If movenumbers is true, move numbers will be included in the string. The moves are numbered from 1, unless some other variable is supplied through the startply parameter.\n\nExamples\n\njulia> b = startboard();\n\njulia> variationtosan(b, map(movefromstring, [\"e2e4\", \"e7e5\", \"g1f3\", \"b8c6\"]))\n\"1. e4 e5 2. Nf3 Nc6\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.variationtosan-Tuple{SimpleGame, Vector{Move}}","page":"API Reference","title":"Chess.variationtosan","text":"variationtosan(g::SimpleGame, v::Vector{Move}; movenumbers=true)::String\nvariationtosan(g::Game, v::Vector{Move}; movenumbers=true)::String\n\nConverts a variation to a string in short algebraic notation.\n\nThe vector of moves v should be a sequence of legal moves from the current board position of the game. If movenumbers is true, move numbers will be included in the string.\n\nExamples\n\njulia> g = Game();\n\njulia> domoves!(g, \"d4\", \"Nf6\", \"c4\", \"e6\", \"Nf3\");\n\njulia> variationtosan(g, map(movefromstring, [\"f8b4\", \"c1d2\", \"d8e7\"]))\n\"3... Bb4+ 4. Bd2 Qe7\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Square-Sets-1","page":"API Reference","title":"Square Sets","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"SquareSet\nisempty\nin\nsquares\nunion\nintersect\n-\n+\nissubset\ntoarray\nsquarecount\nfirst\nremovefirst\nissingleton\nonlyfirst\nshift_n\nshift_s\nshift_e\nshift_w\npawnshift_n\npawnshift_s\npawnshift_nw\npawnshift_ne\npawnshift_sw\npawnshift_se\npawnattacks\nknightattacks\nbishopattacks(blockers::SquareSet, ::Square)\nbishopattacksempty\nrookattacks(blockers::SquareSet, ::Square)\nrookattacksempty\nqueenattacks(blockers::SquareSet, ::Square)\nqueenattacksempty\nkingattacks\nsquaresbetween\npprint(ss::SquareSet)\nfilesquares\nranksquares\nSS_EMPTY\nSS_FILE_A\nSS_FILE_B\nSS_FILE_C\nSS_FILE_D\nSS_FILE_E\nSS_FILE_F\nSS_FILE_G\nSS_FILE_H\nSS_RANK_1\nSS_RANK_2\nSS_RANK_3\nSS_RANK_4\nSS_RANK_5\nSS_RANK_6\nSS_RANK_7\nSS_RANK_8","category":"page"},{"location":"api/#Chess.SquareSet","page":"API Reference","title":"Chess.SquareSet","text":"SquareSet\n\nA type representing a set of squares on the chess board.\n\nThe most common ways of obtaining a square set are:\n\nInitializing it with one or more squares, for instance SquareSet(SQ_D4, SQ_E4, SQ_D5, SQ_E5).\nFrom one of the predefined square set constants, like SS_FILE_C (the squares on the C file) or SS_RANK_7 (the squares on the 7th rank).\nBy extracting it from a chess board. See the Board type for details about this.\nBy performing operations transforming or combining one or more square sets to a new square set.\n\nThe union or intersection of two sets can be computed by the functions union and intersect, or by the corresponding binary operators ∪ and ∩. The complement of a square set is denoted by the unary - operator. The difference between two set is obtained by the setdiff function or by the binary - operator. Subset relationships can be tested by the issubset function or the binary operator ⊆.\n\nTo add or remove a square to a square set, use the + or - operators with the square set as the left operand and the square as the right operand. To test whether a square set contains a square, use s in ss or s ∈ ss.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.isempty","page":"API Reference","title":"Base.isempty","text":"isempty(ss::SquareSet)\n\nDetermine whether a square set is the empty set.\n\nExamples\n\njulia> isempty(SS_RANK_1)\nfalse\n\njulia> isempty(SS_EMPTY)\ntrue\n\njulia> isempty(SS_RANK_1 ∩ SS_RANK_2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.in","page":"API Reference","title":"Base.in","text":"in(s::Square, ss::SquareSet)\n∈(s::Square, ss::SquareSet)\n\nDetermine whether a square is a member of a square set.\n\nExamples\n\njulia> SQ_D7 ∈ SS_RANK_8\nfalse\n\njulia> SQ_D8 ∈ SS_RANK_8\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.squares","page":"API Reference","title":"Chess.squares","text":"squares(ss::SquareSet)\n\nConvert a square set to a vector of squares.\n\nExamples\n\njulia> tostring.(squares(SS_RANK_1))\n8-element Array{String,1}:\n \"a1\"\n \"b1\"\n \"c1\"\n \"d1\"\n \"e1\"\n \"f1\"\n \"g1\"\n \"h1\"\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.union","page":"API Reference","title":"Base.union","text":"union(ss1::SquareSet, ss2::SquareSet)\n∪(ss1::SquareSet, ss2::SquareSet)\n\nCompute the union of two square sets.\n\nThe binary operator ∪ can be used instead of the named function.\n\nExamples\n\njulia> SS_FILE_C ∪ SS_RANK_3\nSquareSet:\n -  -  #  -  -  -  -  -\n -  -  #  -  -  -  -  -\n -  -  #  -  -  -  -  -\n -  -  #  -  -  -  -  -\n -  -  #  -  -  -  -  -\n #  #  #  #  #  #  #  #\n -  -  #  -  -  -  -  -\n -  -  #  -  -  -  -  -\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.intersect","page":"API Reference","title":"Base.intersect","text":"intersect(ss1::SquareSet, ss2::SquareSet)\n∩(ss1::SquareSet, ss2::SquareSet)\n\nCompute the intersection of two square sets.\n\nThe binary operator ∩ can be used instead of the named function.\n\nExamples\n\njulia> SS_FILE_D ∩ SS_RANK_7\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  #  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.:-","page":"API Reference","title":"Base.:-","text":"-(c::PieceColor)\n\nReturns the opposite of a color. Synonymous to coloropp.\n\nExamples\n\njulia> -WHITE\nBLACK\n\njulia> -BLACK\nWHITE\n\n\n\n\n\n-(ss::SquareSet)\n\nThe complement of a square set.\n\nExamples\n\njulia> ss = SquareSet(SQ_C4);\n\njulia> SQ_C4 ∈ ss\ntrue\n\njulia> SQ_D4 ∈ ss\nfalse\n\njulia> SQ_C4 ∈ -ss\nfalse\n\njulia> SQ_D4 ∈ -ss\ntrue\n\n\n\n\n\nsetdiff(ss1::SquareSet, ss2::SquareSet)\n-(ss1::SquareSet, ss2::SquareSet)\n\nThe set of all squares that are in ss1, but not in ss2.\n\nExamples\n\njulia> SquareSet(SQ_A1, SQ_A2, SQ_A3, SQ_B1, SQ_B2, SQ_B3) - SS_RANK_2\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n #  #  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n #  #  -  -  -  -  -  -\n\n\n\n\n\n-(ss::SquareSet, s::Square)\n\nRemove a square from a square set.\n\nIf a non-member square is removed, the set is returned unchanged.\n\nExamples\n\njulia> SquareSet(SQ_A1, SQ_B1) - SQ_B1 == SquareSet(SQ_A1)\ntrue\n\njulia> SS_FILE_A - SQ_H8 == SS_FILE_A\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.:+","page":"API Reference","title":"Base.:+","text":"+(ss::SquareSet, s::Square)\n\nAdd a square to a square set.\n\nIf a square is added that is already a member is added to the set, the set is returned unchanged.\n\nExamples\n\njulia> SquareSet(SQ_A1) + SQ_H8 == SquareSet(SQ_A1, SQ_H8)\ntrue\n\njulia> SS_FILE_A + SQ_A1 == SS_FILE_A\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.issubset","page":"API Reference","title":"Base.issubset","text":"issubset(ss1::SquareSet, ss2::SquareSet)\n⊆(ss1::SquareSet, ss2::SquareSet)\n\nDetermine whether ss1 is a subset of ss2.\n\nExamples\n\njulia> SquareSet(SQ_A1, SQ_A2) ⊆ SS_FILE_A\ntrue\n\njulia> SquareSet(SQ_A1, SQ_B1) ⊆ SS_FILE_A\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.toarray","page":"API Reference","title":"Chess.toarray","text":"toarray(ss::SquareSet, T::Type{<:Number}=Float32)\n\nConvert a square set to a two-dimensional array of the specified element type.\n\nThe returned array's columns corresponds to the files, and the rows to the ranks. The array entries are 1 for the members of the square set, and 0 for non-members.\n\nExamples\n\njulia> toarray(SS_FILE_C ∪ SS_RANK_5, Int)\n8×8 Array{Int64,2}:\n 0  0  1  0  0  0  0  0\n 0  0  1  0  0  0  0  0\n 0  0  1  0  0  0  0  0\n 1  1  1  1  1  1  1  1\n 0  0  1  0  0  0  0  0\n 0  0  1  0  0  0  0  0\n 0  0  1  0  0  0  0  0\n 0  0  1  0  0  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.squarecount","page":"API Reference","title":"Chess.squarecount","text":"squarecount(ss::SquareSet)\n\nThe number of members of a square set.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.first","page":"API Reference","title":"Base.first","text":"first(ss::SquareSet)\n\nThe first square in a square set.\n\nReturns SQ_NONE for an empty square set.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.removefirst","page":"API Reference","title":"Chess.removefirst","text":"removefirst(ss::SquareSet)\n\nRemove the first member of a square set.\n\nExamples\n\njulia> removefirst(SquareSet(SQ_A4, SQ_D5, SQ_F6)) == SquareSet(SQ_D5, SQ_F6)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.issingleton","page":"API Reference","title":"Chess.issingleton","text":"issingleton(ss::SquareSet)\n\nDetermine whether ss contains exactly one square.\n\nExamples\n\njulia> issingleton(SquareSet(SQ_D5))\ntrue\n\njulia> issingleton(SquareSet(SQ_D5, SQ_C5))\nfalse\n\njulia> issingleton(SS_EMPTY)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.onlyfirst","page":"API Reference","title":"Chess.onlyfirst","text":"onlyfirst(ss::SquareSet)\n\nReturn a square set with all squares except the first removed.\n\nExamples\n\njulia> onlyfirst(SquareSet(SQ_A4, SQ_D5, SQ_F6)) == SquareSet(SQ_A4)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.shift_n","page":"API Reference","title":"Chess.shift_n","text":"shift_n(ss::SquareSet)\n\nShift the square set one step in the 'north' direction.\n\nSquares that are shifted off the edge of the board disappear.\n\njulia> shift_n(SS_RANK_2) == SS_RANK_3\ntrue\n\njulia> shift_n(SquareSet(SQ_D3, SQ_E4, SQ_F8)) == SquareSet(SQ_D4, SQ_E5)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.shift_s","page":"API Reference","title":"Chess.shift_s","text":"shift_s(ss::SquareSet)\n\nShift the square set one step in the 'south' direction.\n\nSquares that are shifted off the edge of the board disappear.\n\nExamples\n\njulia> shift_s(SS_RANK_3) == SS_RANK_2\ntrue\n\njulia> shift_s(SquareSet(SQ_C3, SQ_D2, SQ_E1)) == SquareSet(SQ_C2, SQ_D1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.shift_e","page":"API Reference","title":"Chess.shift_e","text":"shift_e(ss::SquareSet)\n\nShift the square set one step in the 'east' direction.\n\nSquares that are shifted off the edge of the board disappear.\n\nExamples\n\njulia> shift_e(SS_FILE_F) == SS_FILE_G\ntrue\n\njulia> shift_e(SquareSet(SQ_F5, SQ_G6, SQ_H7)) == SquareSet(SQ_G5, SQ_H6)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.shift_w","page":"API Reference","title":"Chess.shift_w","text":"shift_w(ss::SquareSet)\n\nShift the square set one step in the 'west' direction.\n\nSquares that are shifted off the edge of the board disappear.\n\njulia> shift_w(SS_FILE_C) == SS_FILE_B\ntrue\n\njulia> shift_w(SquareSet(SQ_C5, SQ_B6, SQ_A7)) == SquareSet(SQ_B5, SQ_A6)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnshift_n","page":"API Reference","title":"Chess.pawnshift_n","text":"pawnshift_n(ss::SquareSet)\n\nShift a square set of pawns one step in the 'north' direction.\n\nThis is identical to the shift_n function except that pawnshift_n is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnshift_s","page":"API Reference","title":"Chess.pawnshift_s","text":"pawnshift_s(ss::SquareSet)\n\nShift a square set of pawns one step in the 'south' direction.\n\nThis is identical to the shift_s function except that pawnshift_s is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnshift_nw","page":"API Reference","title":"Chess.pawnshift_nw","text":"pawnshift_nw(ss::SquareSet)\n\nShift a square set of pawns one step in the 'north west' direction.\n\nThis is identical to calling shift_n followed by shift_w, except that pawnshift_nw is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnshift_ne","page":"API Reference","title":"Chess.pawnshift_ne","text":"pawnshift_ne(ss::SquareSet)\n\nShift a square set of pawns one step in the 'north east' direction.\n\nThis is identical to calling shift_n followed by shift_e, except that pawnshift_ne is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnshift_sw","page":"API Reference","title":"Chess.pawnshift_sw","text":"pawnshift_sw(ss::SquareSet)\n\nShift a square set of pawns one step in the 'south west' direction.\n\nThis is identical to calling shift_s followed by shift_w, except that pawnshift_sw is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnshift_se","page":"API Reference","title":"Chess.pawnshift_se","text":"pawnshift_se(ss::SquareSet)\n\nShift a square set of pawns one step in the 'south east' direction.\n\nThis is identical to calling shift_s followed by shift_e, except that pawnshift_se is a little faster, but will not work for square sets containing squares on the 1st or 8th rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pawnattacks","page":"API Reference","title":"Chess.pawnattacks","text":"pawnttacks(c::PieceColor, s::square)\n\nthe set of squares attacked by a pawn of color c on the square s.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.knightattacks","page":"API Reference","title":"Chess.knightattacks","text":"knightattacks(s::Square)\n\nThe set of squares attacked by a knight on the square s.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.bishopattacks-Tuple{SquareSet, Square}","page":"API Reference","title":"Chess.bishopattacks","text":"bishopattacks(blockers::SquareSet, s::Square)\n\nThe squares attacked by a bishop on s, with blockers being the occupied squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.bishopattacksempty","page":"API Reference","title":"Chess.bishopattacksempty","text":"bishopattacksempty(s::Square)\n\nThe set of squares a bishop on s would attack on an otherwise empty board.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.rookattacks-Tuple{SquareSet, Square}","page":"API Reference","title":"Chess.rookattacks","text":"rookattacks(blockers::SquareSet, s::Square)\n\nThe squares attacked by a rook on s, with blockers being the occupied squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.rookattacksempty","page":"API Reference","title":"Chess.rookattacksempty","text":"rookattacksempty(s::Square)\n\nThe set of squares a rook on s would attack on an otherwise empty board.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.queenattacks-Tuple{SquareSet, Square}","page":"API Reference","title":"Chess.queenattacks","text":"queenattacks(blockers::SquareSet, s::Square)\n\nThe squares attacked by a queen on s, with blockers being the occupied squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.queenattacksempty","page":"API Reference","title":"Chess.queenattacksempty","text":"queenattacksempty(s::Square)\n\nThe set of squares a queen on s would attack on an otherwise empty board.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.kingattacks","page":"API Reference","title":"Chess.kingattacks","text":"kingattacks(s::square)\n\nthe set of squares attacked by a king on the square s.\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.squaresbetween","page":"API Reference","title":"Chess.squaresbetween","text":"squaresbetween(s1::Square, s2::Square)\n\nThe set of squares on the line, file or diagonal between s1 and s2.\n\nWhen a queen on s1 would attack s2 on an otherwise empty board, this function returns the set of squares where a piece would block the queen on s1 from attacking s2.\n\nExamples\n\njulia> squaresbetween(SQ_A4, SQ_D4) == SquareSet(SQ_B4, SQ_C4)\ntrue\n\njulia> squaresbetween(SQ_F7, SQ_A2)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  #  -  -  -\n -  -  -  #  -  -  -  -\n -  -  #  -  -  -  -  -\n -  #  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.pprint-Tuple{SquareSet}","page":"API Reference","title":"Chess.pprint","text":"pprint(ss::SquareSet)\n\nPretty-print a square set to the standard output.\n\n\n\n\n\n","category":"method"},{"location":"api/#Chess.filesquares","page":"API Reference","title":"Chess.filesquares","text":"filesquares(f::SquareFile)\nfilesquares(s::Square)\n\nThe set of all squares on the provided file.\n\nExamples\n\njulia> filesquares(FILE_G) == SS_FILE_G\ntrue\n\njulia> filesquares(SQ_C5) == SS_FILE_C\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.ranksquares","page":"API Reference","title":"Chess.ranksquares","text":"ranksquares(r::SquareRank)\nranksquares(s::Square)\n\nThe set of all squares on the provided rank.\n\nExamples\n\njulia> ranksquares(RANK_2) == SS_RANK_2\ntrue\n\njulia> ranksquares(SQ_C5) == SS_RANK_5\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Chess.SS_EMPTY","page":"API Reference","title":"Chess.SS_EMPTY","text":"SS_EMPTY\n\nAn empty square set, containing no squares.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_A","page":"API Reference","title":"Chess.SS_FILE_A","text":"SS_FILE_A\n\nThe square set containing all the squares along the A file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_B","page":"API Reference","title":"Chess.SS_FILE_B","text":"SS_FILE_B\n\nThe square set containing all the squares along the B file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_C","page":"API Reference","title":"Chess.SS_FILE_C","text":"SS_FILE_C\n\nThe square set containing all the squares along the C file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_D","page":"API Reference","title":"Chess.SS_FILE_D","text":"SS_FILE_D\n\nThe square set containing all the squares along the D file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_E","page":"API Reference","title":"Chess.SS_FILE_E","text":"SS_FILE_E\n\nThe square set containing all the squares along the E file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_F","page":"API Reference","title":"Chess.SS_FILE_F","text":"SS_FILE_F\n\nThe square set containing all the squares along the F file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_G","page":"API Reference","title":"Chess.SS_FILE_G","text":"SS_FILE_G\n\nThe square set containing all the squares along the G file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_FILE_H","page":"API Reference","title":"Chess.SS_FILE_H","text":"SS_FILE_H\n\nThe square set containing all the squares along the H file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_1","page":"API Reference","title":"Chess.SS_RANK_1","text":"SS_RANK_1\n\nThe square set containing all the squares along the 1st rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_2","page":"API Reference","title":"Chess.SS_RANK_2","text":"SS_RANK_2\n\nThe square set containing all the squares along the 2nd rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_3","page":"API Reference","title":"Chess.SS_RANK_3","text":"SS_RANK_3\n\nThe square set containing all the squares along the 3rd rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_4","page":"API Reference","title":"Chess.SS_RANK_4","text":"SS_RANK_4\n\nThe square set containing all the squares along the 4th rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_5","page":"API Reference","title":"Chess.SS_RANK_5","text":"SS_RANK_5\n\nThe square set containing all the squares along the 5th rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_6","page":"API Reference","title":"Chess.SS_RANK_6","text":"SS_RANK_6\n\nThe square set containing all the squares along the 6th rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_7","page":"API Reference","title":"Chess.SS_RANK_7","text":"SS_RANK_7\n\nThe square set containing all the squares along the 7th rank.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Chess.SS_RANK_8","page":"API Reference","title":"Chess.SS_RANK_8","text":"SS_RANK_8\n\nThe square set containing all the squares along the 8th rank.\n\n\n\n\n\n","category":"constant"},{"location":"api-index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"api-index/#","page":"Index","title":"Index","text":"Modules = [Chess, Chess.PGN, Chess.Book, Chess.UCI]\nOrder   = [:function, :type]","category":"page"},{"location":"manual/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Chess.jl is designed to work well with Pluto. For interactive use, working with Chess.jl under Pluto is much nicer than from the Julia REPL. A slightly modified version of this tutorial also exists as a Pluto notebook, available from this link. In order to run it, follow these steps:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Make sure you have Julia 1.6 or later installed.\nAdd the packages Chess, Pluto and PlutoUI to your environment.\nFrom the Julia REPL, do:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> using PlutoUI\n\njulia> Pluto.run()","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Pluto will now open in a browser window. In the \"Open from file\" textbox, navigate to the location of the downloaded tutorial.jl file, and press \"Open\".","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"There is also a static HTML version of the tutorial notebook. Even if you have no interest in using Chess.jl with Pluto, the notebook may be easier to read, because of the graphical chess boards.","category":"page"},{"location":"manual/#Boards-1","page":"Tutorial","title":"Boards","text":"","category":"section"},{"location":"manual/#Creating-boards-1","page":"Tutorial","title":"Creating boards","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"A chess board is represented by the Board type. A board is usually obtained in one of five ways:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"By calling the startboard() function, which returns a board initialized to the standard chess opening position.\nBy using the @startboard macro, which allows you to provide a sequence of moves from the starting position.\nBy calling the fromfen() function, which takes a board string in Forsyth-Edwards Notation and returns the corresponding board.\nBy making a move or a sequence of moves on an existing chess board, using a function like domove() or domoves().\nBy calling the board() function on a Game or a SimpleGame, obtaining the current board position in a game. See the section on games later in this tutorial for a discussion of these types)","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Let's begin with the most basic way of creating a chess board: The startboard() function.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> startboard()\nBoard (rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  P  P  P  P  P\n R  N  B  Q  K  B  N  R","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"If you are using Chess.jl through a Pluto or Jupyter notebook, you'll see a graphical board, along with a link for opening the board in lichess.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Sometimes you want to set up a board position by making some moves from the starting position. You could do this by first calling startboard() and then calling the domoves() or domoves!() function (more about those later in this tutorial), but that quickly becomes tedious for interactive use. The @startboard macro can be used as a convenient shortcut:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> @startboard e4 e5 Nf3 Nc6 Bb5\nBoard (r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq -):\n r  -  b  q  k  b  n  r\n p  p  p  p  -  p  p  p\n -  -  n  -  -  -  -  -\n -  B  -  -  p  -  -  -\n -  -  -  -  P  -  -  -\n -  -  -  -  -  N  -  -\n P  P  P  P  -  P  P  P\n R  N  B  Q  K  -  -  R","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Annoyingly, the minus sign in standard castling notation (O-O for kingside castling and O-O-O for queenside castling) confuses Julia's parser. For castling moves, just skip the minus sign and write OO or OOO, as in the following example.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> @startboard e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 g6 Be3 Bg7 f3 OO Qd2 Nc6 OOO\nBoard (r1bq1rk1/pp2ppbp/2np1np1/8/3NP3/2N1BP2/PPPQ2PP/2KR1B1R b - -):\n r  -  b  q  -  r  k  -\n p  p  -  -  p  p  b  p\n -  -  n  p  -  n  p  -\n -  -  -  -  -  -  -  -\n -  -  -  N  P  -  -  -\n -  -  N  -  B  P  -  -\n P  P  P  Q  -  -  P  P\n -  -  K  R  -  B  -  R","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Setting up an arbitrary board position without entering a move sequence can be done with the fromfen() function:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> fromfen(\"5rk1/p1pb2pp/2p5/3p3q/2P3n1/1Q4BN/PP1Np1KP/R3R3 b - -\")\nBoard (5rk1/p1pb2pp/2p5/3p3q/2P3n1/1Q4BN/PP1Np1KP/R3R3 b - -):\n -  -  -  -  -  r  k  -\n p  -  p  b  -  -  p  p\n -  -  p  -  -  -  -  -\n -  -  -  p  -  -  -  q\n -  -  P  -  -  -  n  -\n -  Q  -  -  -  -  B  N\n P  P  -  N  p  -  K  P\n R  -  -  -  R  -  -  -","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"FEN strings are quite easy to understand. The first component (5rk1/p1pb2pp/2p5/3p3q/2P3n1/1Q4BN/PP1Np1KP/R3R3 in the above example) is the board setup. The ranks of the board are listed from top to bottom (beginning with rank 8), separated by the / character. For each rank, lowercase letters (p, n, b, r, q or k) denote black pieces, while uppercase letters (P, N, B, R, Q or K) denote white pieces. Digits represents empty squares. In the above example, the 8th rank is 5rk1, meaning five empty squares followed by a black rook and a black king, and finally one empty square.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The second component (b in the above example) is the side to move. It is always one of the two characters w or b, depending on the side to move. In this case, it's black.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The third component (- in the example) is the current castle rights. The dash means that neither side has the right to castle. If one or both sides still have the right to castle, the letters K, Q, k and q are used. The uppercase letters mean that white can castle kingside or queenside, while the lowercase letters mean that black can castle. For instance, in a position when both sides can still castle in either direction, the third component would be KQkq. In a position where white can only castle queenside and black only kingside, it would be Qk.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The fourth coponent (- in the example) is the square on which an en passant capture is possible. The dash means that no en passant capture is possible in our case. If an en passant capture had been possible on e3, the fourth component would have been e3.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"For additional examples and explanations, visit the Wikipedia article on FEN strings.","category":"page"},{"location":"manual/#Making-and-Unmaking-Moves-1","page":"Tutorial","title":"Making and Unmaking Moves","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Given a chess board, you will often want to modify the board by making some moves. The most straightforward way to do this is with the domove function, which takes two parameters: A chess board and a move. The move can be either a value of the Move type (you'll learn about this type later in this tutorial) or a string representing a move in UCI or SAN notation.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Here's an example of using domove to make a move given by a string in short algebraic notation (SAN):","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Given a chess board, you will usually want to modify the board by making some moves. The most straightforward way to do this is with the domove function, which takes two parameters: A chess board and a move. The move can be either a value of the Move type or a string representing a move in UCI or SAN notation.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The Move type is described in more detail in the API reference. For now, let's see how to use domove to make a move given in short algebraic notation (SAN):","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> b = startboard();\n\njulia> domove(b, \"d4\")\nBoard (rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  P  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  -  P  P  P  P\n R  N  B  Q  K  B  N  R","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"There is also a function domoves that takes a series of several moves and executes all of them:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> b = startboard();\n\njulia> domoves(b, \"e4\", \"e5\", \"Nf3\", \"Nc6\", \"Bb5\")\nBoard (r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq -):\n r  -  b  q  k  b  n  r\n p  p  p  p  -  p  p  p\n -  -  n  -  -  -  -  -\n -  B  -  -  p  -  -  -\n -  -  -  -  P  -  -  -\n -  -  -  -  -  N  -  -\n P  P  P  P  -  P  P  P\n R  N  B  Q  K  -  -  R","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Note that both of these functions return new boards: The original board b is left unchanged, as illustrated by this example:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> b = startboard();\n\njulia> domove(b, \"c4\");\n\njulia> b\nBoard (rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  P  P  P  P  P\n R  N  B  Q  K  B  N  R","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"This is convenient when writing code in a functional style, or when using a reactive notebook environment like Pluto. Unfortunately, it also results in a lot of copying of data, and heap allocations that may have signifcant performance impacts for certain types of applications. When this is a problem, there are alternative functions domove! and domoves! that destructively modify the input board.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Here is the result of the previous example when modified to use domove!:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> b = startboard();\n\njulia> domove!(b, \"c4\");\n\njulia> b\nBoard (rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR b KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  P  -  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  -  P  P  P  P  P\n R  N  B  Q  K  B  N  R","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"domove! returns a value of type UndoInfo. This can be used to undo the move and go back to the board position before the move was made:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> b = startboard();\n\njulia> u = domove!(b, \"e4\");\n\njulia> b\nBoard (rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  P  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  P  -  P  P  P\n R  N  B  Q  K  B  N  R\n\njulia> undomove!(b, u);\n\njulia> b\nBoard (rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -):\n r  n  b  q  k  b  n  r\n p  p  p  p  p  p  p  p\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  P  P  P  P  P\n R  N  B  Q  K  B  N  R","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"There is also a function domoves!() that can be used to destructively update a board with a sequence of several moves. Unlike domove!, this operation is irreversible. No UndoInfo is generated, and there is no way to undo the moves and return to the original board.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Similarly, domoves! takes a board and a sequence of moves and executes them all, destructively modifying the board. Unlike domove!, this operation is irreversible. There is no way to retract the moves and return to the original board.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> b = startboard();\n\njulia> domoves!(b, \"d4\", \"Nf6\", \"c4\", \"g6\", \"Nc3\", \"Bg7\", \"e4\", \"d6\", \"Nf3\", \"O-O\")\nBoard (rnbq1rk1/ppp1ppbp/3p1np1/8/2PPP3/2N2N2/PP3PPP/R1BQKB1R w KQ -):\n r  n  b  q  -  r  k  -\n p  p  p  -  p  p  b  p\n -  -  -  p  -  n  p  -\n -  -  -  -  -  -  -  -\n -  -  P  P  P  -  -  -\n -  -  N  -  -  N  -  -\n P  P  -  -  -  P  P  P\n R  -  B  Q  K  B  -  R","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Remember that there is also a macro @startboard that allows you to do this more conveniently. The above example could also be written like this:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> @startboard d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 Nf3 OO\nBoard (rnbq1rk1/ppp1ppbp/3p1np1/8/2PPP3/2N2N2/PP3PPP/R1BQKB1R w KQ -):\n r  n  b  q  -  r  k  -\n p  p  p  -  p  p  b  p\n -  -  -  p  -  n  p  -\n -  -  -  -  -  -  -  -\n -  -  P  P  P  -  -  -\n -  -  N  -  -  N  -  -\n P  P  -  -  -  P  P  P\n R  -  B  Q  K  B  -  R","category":"page"},{"location":"manual/#Pieces,-Piece-Colors,-and-Piece-Types-1","page":"Tutorial","title":"Pieces, Piece Colors, and Piece Types","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Chess pieces are represented by the Piece type (internally, a simple wrapper around an integer). There are constants PIECE_WP, PIECE_WN, PIECE_WB, PIECE_WR, PIECE_WQ, PIECE_WK, PIECE_BP, PIECE_BN, PIECE_BB, PIECE_BR, PIECE_BQ and PIECE_BK for each of the possible white or black pieces, and a special piece value EMPTY for the contents of an empty square on the board.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"There are also piece colors, represented by the PieceColor type (possible values WHITE, BLACK and COLOR_NONE), as well as piece types, represented by the PieceType type (possible values PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING and PIECE_TYPE_NONE).","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Given a piece, you can ask for its color and type by using pcolor and ptype:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> pcolor(PIECE_BN)\nBLACK\n\njulia> ptype(PIECE_BN)\nKNIGHT","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Conversely, if you have a PieceColor and a PieceType, you can create a Piece value by calling the Piece constructor:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> Piece(WHITE, ROOK)\nPIECE_WR","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The special Piece value EMPTY has piece color COLOR_NONE and piece type PIECE_TYPE_NONE:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> pcolor(EMPTY)\nCOLOR_NONE\n\njulia> ptype(EMPTY)\nPIECE_TYPE_NONE","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The current side to move of a board is obtained by calling sidetomove:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> sidetomove(startboard())\nWHITE\n\njulia> sidetomove(@startboard Nf3)\nBLACK","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Use the unary minus operator or the function coloropp to invert a color:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> -WHITE\nBLACK\n\njulia> coloropp(BLACK)\nWHITE","category":"page"},{"location":"manual/#Squares-1","page":"Tutorial","title":"Squares","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Squares are represented by the Square data type. Just as for pieces, piece colors, and piece types, this type is internally just a simple wrapper around an integer. There are constants SQ_A1, SQ_A2, ..., SQ_H8 for the 64 squares of the board.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"One of the common uses of Square values is to ask about the contents of a square on a chess board. This is done with the pieceon function:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> pieceon(startboard(), SQ_B1)\nPIECE_WN\n\njulia> pieceon(startboard(), SQ_E8)\nPIECE_BK\n\njulia> pieceon(startboard(), SQ_A3)\nEMPTY","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"There are also two types SquareFile and SquareRank for representing the files and ranks of a board. Given a square, we can get its file or rank by calling file or rank:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> file(SQ_E5)\nFILE_E\n\njulia> rank(SQ_E5)\nRANK_5","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Conversely, it is possible to create a Square from a SquareFile and a SquareRank:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> Square(FILE_C, RANK_4)\nSQ_C4","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"We can use the functions tostring and squarefromstring to convert between Square values and strings:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> tostring(SQ_D4)\n\"d4\"\n\njulia> squarefromstring(\"g6\")\nSQ_G6","category":"page"},{"location":"manual/#Moves-1","page":"Tutorial","title":"Moves","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Moves are represented by the type Move. A Move value can be obtained by calling one of two possible constructors:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> Move(SQ_E2, SQ_E4) # Normal move\nMove(e2e4)\n\njulia> Move(SQ_A7, SQ_A8, QUEEN) # Promotion move\nMove(a7a8q)","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"We can also convert a move to/from strings in UCI notation:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> tostring(Move(SQ_G8, SQ_F6))\n\"g8f6\"\n\njulia> movefromstring(\"b2c1r\")\nMove(b2c1r)","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Parsing move strings in short algebraic notation (SAN) requires a board. Without a board, there is no way to know the source square of a move string like \"Nf3\". Given a board, we can convert to/from SAN move strings using movetosan and movefromsan:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> movetosan(startboard(), Move(SQ_G1, SQ_F3))\n\"Nf3\"\n\njulia> movefromsan(startboard(), \"e4\")\nMove(e2e4)","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"One of the most common ways to obtain a move is to call the moves function on a board. This returns a MoveList, a list of all legal moves for the board:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> b = @startboard e4 c5 Nf3 d6;\n\njulia> moves(b)\n28-element MoveList:\n Move(a2a3)\n Move(b2b3)\n Move(c2c3)\n Move(d2d3)\n Move(e4e5)\n Move(g2g3)\n Move(h2h3)\n Move(a2a4)\n Move(b2b4)\n Move(c2c4)\n ⋮\n Move(f3g1)\n Move(f3h4)\n Move(f1a6)\n Move(f1b5)\n Move(f1c4)\n Move(f1d3)\n Move(f1e2)\n Move(h1g1)\n Move(d1e2)\n Move(e1e2)","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Most of the usual Julia sequence functions should work with MoveList values. For instance, we can filter out only those moves that give check:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> filter(m -> ischeck(domove(b, m)), moves(b))\n1-element Vector{Move}:\n Move(f1b5)","category":"page"},{"location":"manual/#Square-Sets-1","page":"Tutorial","title":"Square Sets","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The SquareSet type represents a set of squares on the chess board. We can do set-theoretic operations like union, intersection and complement on square sets, and test for set membership. Internally, a SquareSet is represented by a 64-bit integer, with set operations performed through bitwise operations. This makes square sets very fast to manipulate.","category":"page"},{"location":"manual/#Creating-Square-Sets-1","page":"Tutorial","title":"Creating Square Sets","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"There is a SquareSet constructor that takes a sequence of squares as input and returns the corresponding square set:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> SquareSet(SQ_A1, SQ_A2, SQ_A3)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n #  -  -  -  -  -  -  -\n #  -  -  -  -  -  -  -\n #  -  -  -  -  -  -  -","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"There are also pre-defined constants SS_FILE_A, ..., SS_FILE_H for the eight files of the board, and SS_RANK_1, ..., SS_RANK_8 for the eight ranks.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> SS_FILE_B\nSquareSet:\n -  #  -  -  -  -  -  -\n -  #  -  -  -  -  -  -\n -  #  -  -  -  -  -  -\n -  #  -  -  -  -  -  -\n -  #  -  -  -  -  -  -\n -  #  -  -  -  -  -  -\n -  #  -  -  -  -  -  -\n -  #  -  -  -  -  -  -\n\njulia> SS_RANK_6\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n #  #  #  #  #  #  #  #\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -","category":"page"},{"location":"manual/#Extracting-Square-Sets-From-Boards-1","page":"Tutorial","title":"Extracting Square Sets From Boards","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Given a Board value, there are several functions for obtaining various square sets. The pieces function has several methods for extracting sets of squares occupied by various pieces.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The squares occupied by white pieces:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> pieces(startboard(), WHITE)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The set of all squares occupied by pawns of either color (you can also do pawns(startboard()), with the same effect):","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> pieces(startboard(), PAWN)\nSquareSet:\n -  -  -  -  -  -  -  -\n #  #  #  #  #  #  #  #\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n #  #  #  #  #  #  #  #\n -  -  -  -  -  -  -  -","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The set of squares occupied by black knights (you can also do knights(startboard(), BLACK)):","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> pieces(startboard(), PIECE_BN)\nSquareSet:\n -  #  -  -  -  -  #  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The set of all occupied squares on the board:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> occupiedsquares(startboard())\nSquareSet:\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The set of all empty squares on the board:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> emptysquares(startboard())\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -","category":"page"},{"location":"manual/#Set-Operations-1","page":"Tutorial","title":"Set Operations","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"It is possible to do various basic set theoretic operations likecomplement, union, increment, and membership tests on square sets, using standard mathematical notation. This sections gives a few examples.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Set membership tests (type \\in <TAB> and \\notin <TAB> for the ∈ and ∉ characters):","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> SQ_D1 ∈ SS_FILE_D\ntrue\n\njulia> SQ_D1 ∈ SS_RANK_2\nfalse\n\njulia> SQ_E4 ∉ SS_RANK_8\ntrue","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Set complement:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> -SS_RANK_4\nSquareSet:\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #\n -  -  -  -  -  -  -  -\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #\n #  #  #  #  #  #  #  #","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Set union (type \\cup <TAB> for the ∪ character):","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> SS_RANK_2 ∪ SS_FILE_F\nSquareSet:\n -  -  -  -  -  #  -  -\n -  -  -  -  -  #  -  -\n -  -  -  -  -  #  -  -\n -  -  -  -  -  #  -  -\n -  -  -  -  -  #  -  -\n -  -  -  -  -  #  -  -\n #  #  #  #  #  #  #  #\n -  -  -  -  -  #  -  -","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Set intersection (type \\cap <TAB> for the ∩ character):","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> SS_FILE_D ∩ SquareSet(SQ_D4, SQ_D5, SQ_E4, SQ_E5)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  #  -  -  -  -\n -  -  -  #  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Set subtraction:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> SS_FILE_G - (SS_RANK_3 ∪ SS_RANK_4)\nSquareSet:\n -  -  -  -  -  -  #  -\n -  -  -  -  -  -  #  -\n -  -  -  -  -  -  #  -\n -  -  -  -  -  -  #  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  #  -\n -  -  -  -  -  -  #  -","category":"page"},{"location":"manual/#Attack-Square-Sets-1","page":"Tutorial","title":"Attack Square Sets","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Chess.jl contains several functions for generating attacks to/from squares on the chess board.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Attacks by knights, kings or pawns from a given square on the board are the most straightforward.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The squares attacked by a knight on e5:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> knightattacks(SQ_E5)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  #  -  #  -  -\n -  -  #  -  -  -  #  -\n -  -  -  -  -  -  -  -\n -  -  #  -  -  -  #  -\n -  -  -  #  -  #  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The squares attacked by a king on g2:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> kingattacks(SQ_G2)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  #  #  #\n -  -  -  -  -  #  -  #\n -  -  -  -  -  #  #  #","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The squares attacked by a black pawn on c5 (the color is necessary here, because white and black pawns move in the opposite direction):","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> pawnattacks(BLACK, SQ_C5)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  #  -  #  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Sliding pieces (bishops, rooks and queens) are a little more complicated, because we need the set of occupied squares on the board in order to identify possible blockers before we can know what squares they attack.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The most common way of providing a set of occupied squares is to use an actual chess board. Let's first create a board position a little more interesting than the starting position.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> b = @startboard e4 e5 Nf3 Nc6 d4 exd4 Nxd4 Bc5\nBoard (r1bqk1nr/pppp1ppp/2n5/2b5/3NP3/8/PPP2PPP/RNBQKB1R w KQkq -):\n r  -  b  q  k  -  n  r\n p  p  p  p  -  p  p  p\n -  -  n  -  -  -  -  -\n -  -  b  -  -  -  -  -\n -  -  -  N  P  -  -  -\n -  -  -  -  -  -  -  -\n P  P  P  -  -  P  P  P\n R  N  B  Q  K  B  -  R","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The set of squares attacked by the white queen on d1:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> queenattacks(b, SQ_D1)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  #\n -  -  -  #  -  -  #  -\n -  -  -  #  -  #  -  -\n -  -  #  #  #  -  -  -\n -  -  #  -  #  -  -  -","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The set of squares a bishop on c4 would have attacked (there is no bishop on c4 at the moment, but this does not stop us from asking which squares a hypothetical bishop there would attack):","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> bishopattacks(b, SQ_C4)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  #  -  -\n #  -  -  -  #  -  -  -\n -  #  -  #  -  -  -  -\n -  -  -  -  -  -  -  -\n -  #  -  #  -  -  -  -\n #  -  -  -  #  -  -  -\n -  -  -  -  -  #  -  -","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"There is also an attacksfrom function, that returns the set of squares attacked by the piece on a given non-empty square, and an attacksto function, that returns all squares that contains pieces of either side that attacks a given square:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> attacksfrom(b, SQ_H8)\nSquareSet:\n -  -  -  -  -  -  #  -\n -  -  -  -  -  -  -  #\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n\njulia> attacksto(b, SQ_D4)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  #  -  -  -  -  -\n -  -  #  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  #  -  -  -  -","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"It is possible to identify pieces that can be captured by intersecting attack square sets with sets of pieces of a given color:`","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> attacksfrom(b, SQ_D4) ∩ pieces(b, BLACK)\nSquareSet:\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  #  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -\n -  -  -  -  -  -  -  -","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Here is a more complicated example: A function that finds all pieces of a given side that are attacked, but undefended:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"function attacked_but_undefended(board, color)\n    attacker = -color  # The opposite color\n\n    # Find all attacked squares\n    attacked = SS_EMPTY  # The empty square set\n    for s ∈ pieces(board, attacker)\n        attacked = attacked ∪ attacksfrom(board, s)\n    end\n\n    # Find all defended squares\n    defended = SS_EMPTY\n    for s ∈ pieces(b, color)\n        defended = defended ∪ attacksfrom(board, s)\n    end\n\n    # Return all attacked, but undefended squares containing pieces of\n    # the desired color:\n    attacked ∩ -defended ∩ pieces(board, color)\nend","category":"page"},{"location":"manual/#Iterating-Through-Square-Sets-1","page":"Tutorial","title":"Iterating Through Square Sets","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The squares function can be used to convert a SquareSet to a vector of squares:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> squares(SS_FILE_A)\n8-element Vector{Square}:\n SQ_A8\n SQ_A7\n SQ_A6\n SQ_A5\n SQ_A4\n SQ_A3\n SQ_A2\n SQ_A1","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The squares function is not necessary for most tasks. It is possible – and much more efficient – to iterate through a SquareSet directly:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> for s ∈ SS_RANK_5\n           println(tostring(s))\n       end\na5\nb5\nc5\nd5\ne5\nf5\ng5\nh5","category":"page"},{"location":"manual/#Games-1","page":"Tutorial","title":"Games","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"There are two types for representing chess games: SimpleGame and Game. SimpleGame is a basic type that contains little more than the PGN headers (player names, game result, etc.) and a sequence of moves. Game is a more complicated type that support annotated, tree-like games with comments and variations. If you don't need these features, SimpleGame is always a better choice, as manipulating a SimpleGame is much faster.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"For the rest of this section, most of our examples use the more complicated Game type. With a few exceptions (that will be pointed out), methods with identical names and behavior exist for the SimpleGame type. Remember again that SimpleGame is really the preferred type in practice, unless you really need the extra functionality of the Game type.","category":"page"},{"location":"manual/#Creating-Games-and-Adding-Moves-1","page":"Tutorial","title":"Creating Games and Adding Moves","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"To create an empty game from the standard chess position, use the parameterless Game() constructor:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> g = Game()\nGame:\n  *","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The printed representation of the game consists of the moves in short algebraic notation (in this case, because we just constructed a game, there are no moves) and an asterisk (*) showing our current position in the game.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Moves can be added to the game with the domove! function:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> g = Game();\n\njulia> domove!(g, \"c4\");\n\njulia> domove!(g, \"e5\");\n\njulia> domove!(g, \"Nc3\");\n\njulia> domove!(g, \"Nf6\");\n\njulia> g\nGame:\n 1. c4 e5 2. Nc3 Nf6 *","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Constructing games this way quickly becomes tedious. For interactive use, there is a macro @game (and a similar macro @simplegame for the SimpleGame type) for constructing a game from the regular starting position with a sequence of moves. The following is equivalent to the above example:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> g = @game c4 e5 Nc3 Nf6\nGame:\n 1. c4 e5 2. Nc3 Nf6 *","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"There is now a list of moves in the printed representation of the game. The * symbol still indicates our current position in the game. We can go back one move by calling back!, forward one move by calling forward!, or jump to the beginning or the end of the game by calling tobeginning! or toend!.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> back!(g)\nGame:\n 1. c4 e5 2. Nc3 * Nf6\n\njulia> tobeginning!(g)\nGame:\n * 1. c4 e5 2. Nc3 Nf6\n\njulia> forward!(g)\nGame:\n 1. c4 * e5 2. Nc3 Nf6\n\njulia> toend!(g)\nGame:\n 1. c4 e5 2. Nc3 Nf6 *","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"You can obtain the current position board position of the game with the board function, which returns a value of type Board:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> board(g)\nBoard (rnbqkb1r/pppp1ppp/5n2/4p3/2P5/2N5/PP1PPPPP/R1BQKBNR w KQkq -):\n r  n  b  q  k  b  -  r\n p  p  p  p  -  p  p  p\n -  -  -  -  -  n  -  -\n -  -  -  -  p  -  -  -\n -  -  P  -  -  -  -  -\n -  -  N  -  -  -  -  -\n P  P  -  P  P  P  P  P\n R  -  B  Q  K  B  N  R","category":"page"},{"location":"manual/#Example:-Playing-Random-Games-1","page":"Tutorial","title":"Example: Playing Random Games","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"By putting together things we've learned earlier in this tutorial, we can now generate random games. This function generates a SimpleGame containing random moves:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"function randomgame()\n    game = SimpleGame()\n    while !isterminal(game)\n        move = rand(moves(board(game)))\n        domove!(game, move)\n    end\n    game\nend","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The only new function in the above code is isterminal, which tests for a game over condition (checkmate or some type of immediate draw).","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Approximately how often do completely random games end in checkmate? Let's find out. The following function takes an optional number of games as input (by default, one thousand), generates the deseired number of random games, and returns the fraction of the games that (accidentally) ends in checkmate.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"function checkmate_fraction(game_count = 1000)\n    checkmate_count = 0\n    for _ in 1:game_count\n        g = randomgame()\n        if ischeckmate(board(g))\n            checkmate_count += 1\n        end\n    end\n    checkmate_count / game_count\nend","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The above code introduces the new function ischeckmate, which tests if a board is a checkmate position.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Let's test it:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> checkmate_fraction(10_000)\n0.1546","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"It seems that about 15% of all random games end in an accidental checkmate. To me, this is a suprisingly high number.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"What will happen if we make random moves, except that we always play the mating move if there is a mate in one? Let's find out. As a first step, let's write a function that checks whether a move is a mate in one.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"move_is_mate_slow(board, move) = ischeckmate(domove(board, move))","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"This is simple, elegant and readable. Unfortunately, as the name indicates, it is also kind of slow. The reason is that domove copies the board. Using the destructive domove! function performs much better, at the price of longer and less readable code.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The function below is functionally equivalent to the one above, but performs much better.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"function move_is_mate(board, move)\n    # Do the move\n    u = domove!(board, move)\n\n    # Check if the resulting board is checkmate\n    result = ischeckmate(board)\n\n    # Undo the move\n    undomove!(board, u)\n\n    # Return result\n    result\nend","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Using the function we just wrote, we can make a function that takes a board as input and returns a mate in 1 move if there is one, or a random move otherwise.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"function mate_or_random(board)\n    ms = moves(board)\n    for move ∈ ms\n        if move_is_mate(board, move)\n            return move\n        end\n    end\n    rand(ms)\nend","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The function below is identical to the randomgame function above, except that it uses mate_or_random instead of totally random moves:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"function almost_random_game()\n    game = SimpleGame()\n    while !isterminal(game)\n        move = mate_or_random(board(game))\n        domove!(game, move)\n    end\n    game\nend","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"What percentage of the games end in checkmate now? Here's a function to find out:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"function checkmate_fraction_2(game_count = 1000)\n    checkmate_count = 0\n    for _ in 1:game_count\n        g = almost_random_game()\n        if ischeckmate(board(g))\n            checkmate_count += 1\n        end\n    end\n    checkmate_count / game_count\nend","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"If you try to run this function, you should get a number around 0.81. About 81% of all completely random games include at least one opportunity to deliver mate in 1!","category":"page"},{"location":"manual/#Variations-1","page":"Tutorial","title":"Variations","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"If we create a game with some moves, go back to an earlier place in the game, and call domove! again with a new move, the previous game continuation is overwritten:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> g = @game d4 d5 c4 e6 Nc3 Nf6 Bg5\nGame:\n 1. d4 d5 2. c4 e6 3. Nc3 Nf6 4. Bg5 *\n\njulia> back!(g); back!(g); back!(g)\nGame:\n 1. d4 d5 2. c4 e6 * 3. Nc3 Nf6 4. Bg5\n\njulia> domove!(g, \"Nf3\")\nGame:\n 1. d4 d5 2. c4 e6 3. Nf3 *","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"This is not always desirable. Sometimes we want to add an alternative move, and to view the game as a tree of variations.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Games of type Game (but not SimpleGame!) are able to handle variations.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"To add an alternative variation at some point in the game, first make the main line, then go back to the place where you want to add the alternative move, and then do addmove!. The following example is identical to the one above, except that domove! has been replaced by addmove!:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> g = @game d4 d5 c4 e6 Nc3 Nf6 Bg5;\n\njulia> back!(g); back!(g); back!(g)\nGame:\n 1. d4 d5 2. c4 e6 * 3. Nc3 Nf6 4. Bg5\n\njulia> addmove!(g, \"Nf3\")\nGame:\n 1. d4 d5 2. c4 e6 3. Nc3 (3. Nf3 *) Nf6 4. Bg5","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Alternative variations are printed in parens in the text representation of a game; the (3. Nf3 *) in the above example. As before, the * indicates the current location in the game tree.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The function forward! takes an optional second argument: Which move to follow when going forward at a branching point in the tree. If this argument is ommited, the main (i.e. first) move is followed.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Here is how you would go back to the point after 3. Nc3 in the above example:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> back!(g)\nGame:\n 1. d4 d5 2. c4 e6 * 3. Nc3 (3. Nf3) Nf6 4. Bg5\n\njulia> forward!(g, \"Nc3\")\nGame:\n 1. d4 d5 2. c4 e6 3. Nc3 (3. Nf3) * Nf6 4. Bg5","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Two other functions that are useful for navigating games with variations are tobeginningofvariation! and toendofvariation!. See the documentation of these functions for details.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Of course, variations can be nested:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> g = @game e4 c5 Nf3 Nc6;\n\njulia> back!(g)\nGame:\n 1. e4 c5 2. Nf3 * Nc6\n\njulia> g = @game e4 c5 Nf3 Nc6;\n\njulia> back!(g); back!(g);\n\njulia> addmove!(g, \"c3\"); addmove!(g, \"Nf6\"); addmove!(g, \"e5\");\n\njulia> back!(g); back!(g);\n\njulia> addmove!(g, \"d5\"); addmove!(g, \"exd5\");\n\njulia> g\nGame:\n 1. e4 c5 2. Nf3 (2. c3 Nf6 (2... d5 3. exd5 *) 3. e5) Nc6","category":"page"},{"location":"manual/#Comments-1","page":"Tutorial","title":"Comments","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Games of type Game (again, not SimpleGame) can also be annotated with textual comments, by using the addcomment! function:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia>  g = @game d4 f5;\n\njulia> addcomment!(g, \"This opening is known as the Dutch Defense\");\n\njulia> g\nGame:\n 1. d4 f5 {This opening is known as the Dutch Defense} *","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Comments are printed in curly braces in the textual representation of games, as can be seen above.","category":"page"},{"location":"manual/#Numeric-Annotation-Glyphs-1","page":"Tutorial","title":"Numeric Annotation Glyphs","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"It is also possible to add numeric annotation glyphs (NAGs) to the game. NAGs are a standard way of adding symbolic annotations to a chess game. All integers in the range 0 to 139 have a pre-defined meaning, as described in this Wikipedia article.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Here is how to add the NAG $4 (\"very poor move or blunder\") to the move 2... g4 in the game 1. f4 e5 2. g4 Qh4#:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> g = @game f4 e5 g4 Qh4;\n\njulia> back!(g);\n\njulia> addnag!(g, 4);\n\njulia> g\nGame:\n 1. f4 e5 2. g4 $4 * Qh4#","category":"page"},{"location":"manual/#PGN-Import-and-Export-1","page":"Tutorial","title":"PGN Import and Export","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"This section describes import and export of chess games in the popular PGN format. PGN is a rather awkward and complicated format, and a lot of the \"PGN files\" out there on the Internet don't quite follow the standard, and are broken in various ways. The functions described in this section do a fairly good job of handling correct PGNs (although bugs are possible), but will often fail on the various not-quite-PGNs found on the Internet.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The PGN functions are found in the submodule Chess.PGN. Please do","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"using Chess, Chess.PGN","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"before trying the examples in this section.","category":"page"},{"location":"manual/#Creating-a-Game-From-a-PGN-String-1","page":"Tutorial","title":"Creating a Game From a PGN String","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Given a PGN string, the gamefromstring function creates a game object from the string (throwing a PGNException on failure). Here's a PGN string for us to experiment with:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> pgnstring = \"\"\"\n       [Event \"Important Tournament\"]\n       [Site \"Somewhere\"]\n       [Date \"2021.04.29\"]\n       [Round \"42\"]\n       [White \"Sixpack, Joe\"]\n       [Black \"Public, John Q\"]\n       [Result \"0-1\"]\n\n       1. f4 e5 2. fxe5 d6 3. exd6 Bxd6 4. Nc3 \\$4 {A terrible blunder. White should\n       play} (4. Nf3 {, and Black has insufficient compensation for the pawn.}) Qh4+\n       5. g3 Qxg3+ {Black could also have played} (5... Bxg3+ 6. hxg3 Qxg3#) 6. hxg3\n       Bxg3# 0-1\n       \"\"\";","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Let's try to import it:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> sg = gamefromstring(pgnstring)\nSimpleGame (Sixpack, Joe vs Public, John Q, Somewhere 2021):\n * 1. f4 e5 2. fxe5 d6 3. exd6 Bxd6 4. Nc3 Qh4+ 5. g3 Qxg3+ 6. hxg3 Bxg3#","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The result is a SimpleGame. All comments, variations and NAGs in the PGN string were ignored. If we instead want a Game with all annotations included, we can supply the value true to the optional parameter annotations:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> g = gamefromstring(pgnstring, annotations=true)\nGame (Sixpack, Joe vs Public, John Q, Somewhere 2021):\n * 1. f4 e5 2. fxe5 d6 3. exd6 Bxd6 4. Nc3 $4 {A terrible blunder. White should\nplay} (4. Nf3 {, and Black has insufficient compensation for the pawn.}) Qh4+ 5. g3 Qxg3+ {Black could also have played} (5... Bxg3+ 6. hxg3 Qxg3#) 6. hxg3 Bxg3#","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Unless you really need the annotations, importing to a SimpleGame is the preferred choice. A SimpleGame is much faster to create and consumes less memory.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Converting a game to a PGN string is done by the gametopgn function. This works for both SimpleGame and Game objects:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> println(gametopgn(sg))\n[Event \"Important Tournament\"]\n[Site \"Somewhere\"]\n[Date \"2021.04.29\"]\n[Round \"42\"]\n[White \"Sixpack, Joe\"]\n[Black \"Public, John Q\"]\n[Result \"0-1\"]\n\n1. f4 e5 2. fxe5 d6 3. exd6 Bxd6 4. Nc3 Qh4+ 5. g3 Qxg3+ 6. hxg3 Bxg3# 0-1\n\njulia> println(gametopgn(g))\n[Event \"Important Tournament\"]\n[Site \"Somewhere\"]\n[Date \"2021.04.29\"]\n[Round \"42\"]\n[White \"Sixpack, Joe\"]\n[Black \"Public, John Q\"]\n[Result \"0-1\"]\n\n1. f4 e5 2. fxe5 d6 3. exd6 Bxd6 4. Nc3 $4 {A terrible blunder. White should\nplay} (4. Nf3 {, and Black has insufficient compensation for the pawn.}) Qh4+ 5. g3 Qxg3+ {Black could also have played} (5... Bxg3+ 6. hxg3 Qxg3#) 6. hxg3 Bxg3# 0-1","category":"page"},{"location":"manual/#Working-With-PGN-Files-1","page":"Tutorial","title":"Working With PGN Files","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Given a file with one or more PGN games, the function gamesinfile returns a Channel of game objects, one for each game in the file. Like gamefromstring, gamesinfile takes an optional named parameter annotations. If annotations is false (the default), you get a channel of SimpleGames. If it's true, you get a channel of Games with the annotations (comments, variations and numeric annotation glyphs) included in the PGN games.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"As an example, here's a function that scans a PGN file and returns a vector of all games that end in checkmate:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"function checkmategames(pgnfilename::String)\n    result = SimpleGame[]\n    for g in gamesinfile(pgnfilename)\n        toend!(g)\n        if ischeckmate(g)\n            push!(result, g)\n        end\n    end\n    result\nend","category":"page"},{"location":"manual/#Opening-Books-1","page":"Tutorial","title":"Opening Books","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The opening book function are located not in the main Chess module, but in the submodule Chess.Book.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"using Chess.Book","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The Chess.Book module contains functions for processing large PGN files and creating opening book files. There is also a small built-in opening book. The rest of the examples in this section will use the built-in opening book. For information about generating your own books, consult the documentation for the Chess.Book module.","category":"page"},{"location":"manual/#Finding-Book-Moves-1","page":"Tutorial","title":"Finding Book Moves","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Given a Board, the function findbookentries finds all the opening book moves for that board position. For instance, this gives us all book moves for the standard opening position:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> b = startboard();\n\njulia> entries = findbookentries(b);","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The return value is a vector of BookEntry structs. This struct contains the following slots:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"move: The move played. For space reasons, the move is stored as an Int32 value. To get the actual Move, do Move(entry.move).\nwins: The number of times the player who played this move won the game.\ndraws: The number of times the game was drawn when this move was played.\nlosses: The number of times the player who played this move lost the game.\nelo: The Elo rating of the highest rated player who played this move.\noppelo: The Elo rating of the highest rated opponent against whom this move was played.\nfirstyear: The first year this move was played.\nlastyear: The last year this move was played.\nscore: The score of the move, used to decide the probability that this move is played when picking a book move to play. The score is computed based on the move's win/loss/draw statistics and its popularity, especially in recent games and games with strong players.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"To print out the stats for all moves for a position, use printbookentries:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> printbookentries(@startboard d4 Nf6 c4 e6 Nc3)\nmove     prob   score     won   drawn    lost    elo oelo  first last\nBb4    71.92%  48.18%   32327   35691   36120   3936 3936   1854 2020\nd5     20.82%  40.46%    4481    6545    8137   3796 3796   1880 2020\nc5      4.20%  43.13%    1560    1192    2247   3794 3851   1922 2020\nb6      2.16%  34.51%     217     170     488   2652 2762   1902 2020\nBe7     0.51%  27.47%      28      33     101   2585 2640   1911 2020\nc6      0.20%  36.05%      13       5      25   2448 2670   1932 2020\ng6      0.12%  31.94%       9       5      22   2289 2405   1943 2020\nNc6     0.06%  33.33%       6      10      17   3809 3809   1938 2020","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The output columns have the following meanings:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"move: The move.\nprob: Probability that this move will be played when calling pickbookmove.\nscore: Percentage score of this move in the games used to produce this book file.\nwon: Number of games won with this move.\ndrawn: Number of games drawn with this move.\nlost: Number of games lost with this move.\nelo: Maximum Elo of players that played this move.\noelo: Maximum Elo of opponents against which this move was played.\nfirst: The first year this move was played.\nlast: The last year this move was played.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"To pick a book move, use pickbookmove:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> pickbookmove(@startboard e4 c5)\nMove(b1c3)","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"pickbookmove also takes some optional named parameter for selecting a book file to use and to eliminate moves that have only been played very rarely. See the function documentation for details.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"If no book moves are found for the input position, pickbookmove returns nothing.","category":"page"},{"location":"manual/#Example:-Playing-Random-Openings-1","page":"Tutorial","title":"Example: Playing Random Openings","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Here's a function that generates a game (or rather, the beginning of a game) by picking and playing book moves until it reaches a position where no book move is found:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"function random_opening()\n    g = Game()\n    while true\n        move = pickbookmove(board(g))\n        if isnothing(move)\n            break\n        end\n        domove!(g, move)\n    end\n    g\nend","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Let's try:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> random_opening()\nGame:\n Nf3 c5 c4 Nc6 Nc3 Nf6 e3 g6 d4 cxd4 exd4 d5 cxd5 Nxd5 Qb3 Nxc3 bxc3 Bg7 Be2 O-O O-O Qc7 *","category":"page"},{"location":"manual/#Creating-Book-Files-1","page":"Tutorial","title":"Creating Book Files","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"To create an opening book, use the createbook function, and supply it with one or more PGN files:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> bk = createbook(\"/path/to/SomeGameDatabase.pgn\");","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"createbook also accepts a number of optional named parameters that configure the scoring of the book moves and what moves are included and excluded. See the function documentation for details.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Please note that while Chess.jl's PGN parser works pretty well for processing correct PGN, it's not very robust when it comes to parsing \"PGN files\" that fail to follow the standard. Annoyingly, even popular software like ChessBase sometimes generate broken PGN files (failing to escape quotes in strings is a particularly frequent problem). If you feed createbook with a non-standard PGN file, it will often fail.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"For large databases with millions of games, creating a book consumes a lot of memory, since all the data is stored in RAM.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The first thing you want to do after creating an opening book is probably to write it to disk. Assuming that we stored the result of createbook in a variable bk, like above, we save the book like this:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> writebooktofile(bk, \"/path/to/mybook.obk\")","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Opening book files can be very large, because they contain every move that has been played even once in the input PGN databases. The function purgebook can create a smaller book from a large book by only including moves which have been played several times and/or have high scores (the score of a move is computed based on how well it has been formed and by how popular it is, with more weight being given to recent games and games played by strong players). purgebook has two required parameters, an input file name and an output file name. The optional named parameters minscore (default 0) and mingamecount (default 5) control what moves are included in the output file.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Example usage:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> purgebook(\"/path/to/mybook.obk\", \"/path/to/mybook-small.obk\", minscore=0.01, mingamecount=10)","category":"page"},{"location":"manual/#Interacting-with-UCI-Engines-1","page":"Tutorial","title":"Interacting with UCI Engines","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"This section describes how to run and interact with chess engines using the Universal Chess Interface protocol. There are hundreds of UCI chess engines out there. A free, strong and popular choice is Stockfish. Stockfish is used as an example in this section, but any other engine should work just as well.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"For running the examples in this section, it is assumed that you have an executable stockfish somewhere in your PATH environment variable.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The code for interacting with UCI engines is found in the submodule Chess.UCI:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> using Chess.UCI","category":"page"},{"location":"manual/#Starting-and-Initializing-Engines-1","page":"Tutorial","title":"Starting and Initializing Engines","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"An engine is started by calling the runengine function, which takes the path to the engine as a parameter:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"An engine is started by calling the runengine command, which takes the path to the engine as a parameter:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> sf = runengine(\"stockfish\")\nEngine: Stockfish 160421","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The first thing you want to do after starting a chess engine is probably to set some UCI parameter values. This can be done with setoption:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> setoption(sf, \"Hash\", 256);","category":"page"},{"location":"manual/#Searching-1","page":"Tutorial","title":"Searching","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"You can send a game to the engine with setboard:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> g = @simplegame f4 e5 fxe5 d6 exd6 Bxd6 Nc3;\n\njulia> setboard(sf, g)","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The second parameter to setboard can also be a Board or a Game.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"To ask the engine to search the position you just sent to it, use the search function. search has two required parameters: The engine and the UCI go command we want to send to it.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Here is the most basic example of using search:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> search(sf, \"go depth 10\")\nBestMoveInfo (best=d8h4, ponder=g2g3)","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The return value is a BestMoveInfo, a struct containing the two slots bestmove (the best move returned by the engine, a Move) and ponder (the ponder move returned by the engine, a Move or nothing).","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The search function also takes an optional named parameter infoaction. This parameter is a function that takes each of the engine's info output lines and does something to them. Here's an example where we just print the engine output with println as our infoaction:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> g = @simplegame d4 Nf6 c4 g6 Nc3 d5 cxd5 Nxd5;\n\njulia> setboard(sf, g)\n\njulia> search(sf, \"go depth 10\", infoaction = println)\ninfo string NNUE evaluation using nn-62ef826d1a6d.nnue enabled\ninfo depth 1 seldepth 1 multipv 1 score cp 113 nodes 49 nps 24500 tbhits 0 time 2 pv g1f3\ninfo depth 2 seldepth 2 multipv 1 score cp 114 nodes 170 nps 85000 tbhits 0 time 2 pv g1f3 d5c3\ninfo depth 3 seldepth 3 multipv 1 score cp 114 nodes 246 nps 123000 tbhits 0 time 2 pv g1f3 d5c3 b2c3\ninfo depth 4 seldepth 4 multipv 1 score cp 195 nodes 301 nps 150500 tbhits 0 time 2 pv g1f3 d5c3\ninfo depth 5 seldepth 5 multipv 1 score cp 224 nodes 886 nps 295333 tbhits 0 time 3 pv g1f3 d5c3 b2c3\ninfo depth 6 seldepth 6 multipv 1 score cp 113 nodes 1264 nps 316000 tbhits 0 time 4 pv g1f3 d5c3 b2c3 f8g7 e2e4 e8g8\ninfo depth 7 seldepth 7 multipv 1 score cp 87 nodes 2326 nps 465200 tbhits 0 time 5 pv g1f3 d5c3 b2c3 f8g7 e2e4 e8g8 f1d3\ninfo depth 8 seldepth 11 multipv 1 score cp 43 nodes 6660 nps 740000 tbhits 0 time 9 pv e2e4 d5c3 b2c3 c7c5 f1b5 c8d7 d1b3 f8g7 b5d7 b8d7\ninfo depth 9 seldepth 14 multipv 1 score cp 61 nodes 9085 nps 698846 tbhits 0 time 13 pv e2e4 d5c3 b2c3 c7c5 g1f3 c5d4 d1d4\ninfo depth 10 seldepth 14 multipv 1 score cp 30 nodes 24385 nps 762031 tbhits 0 time 32 pv e2e4 d5c3 b2c3 c7c5 f1b5 c8d7 b5d7 b8d7 g1f3 f8g7 e1g1 e8g8 c1e3\nBestMoveInfo (best=e2e4, ponder=d5c3)","category":"page"},{"location":"manual/#Parsing-Search-Output-1","page":"Tutorial","title":"Parsing Search Output","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"In most cases, we want something more easily to manipulate than the raw string values sent by the engines info lines in our infoaction function. The function parsesearchinfo takes care of this. It takes an info string as input and returns a SearchInfo value, a struct that contains the various components of the info line as its slots.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Let's see how this works:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> parsesearchinfo(\"info depth 10 seldepth 14 multipv 1 score cp 30 nodes 24385 nps 762031 tbhits 0 time 32 pv e2e4 d5c3 b2c3 c7c5 f1b5 c8d7 b5d7 b8d7 g1f3 f8g7 e1g1 e8g8 c1e3\")\nSearchInfo:\n depth: 10\n seldepth: 14\n time: 32\n nodes: 24385\n nps: 762031\n score: Score(30, false, Chess.UCI.exact)\n tbhits: 0\n multipv: 1\n pv: e2e4 d5c3 b2c3 c7c5 f1b5 c8d7 b5d7 b8d7 g1f3 f8g7 e1g1 e8g8 c1e3","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The meaning of most of the slots in this struct should be evident if you are familiar with the UCI protocol. If you are not, the two most important slots are the score and the pv.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The score is a value of type Score. The definition of the Score struct looks like this:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"struct Score\n    value::Int\n    ismate::Bool\n    bound::BoundType\nend","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"There are two types of score: Centipawn scores are an evaluation where advantages is measured on a scale where 100 means an advantage corresponding to the value of one pawn. Mate scores are scores of the type \"mate in X moves\". The type of score is indicated by the ismate slot, while the numerical value is indicated by the value slot.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"For instance, when value is 50 and ismate is false, it means that the side to move has an advantage worth about half a pawn. If value is 5 and ismate is true, it means that the side to move has a forced checkmate in 5 half moves or less.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The final slot, bound, indicates whether the score is just an upper bound, a lower bound, or an exact score. The three possible values are upper, lower and exact.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"When presenting scores to humans, the scorestring function is useful. For centipawn scores, it converts the score to a scale of pawn=1.0, and outputs the score with a single decimal:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> scorestring(Score(-87, false, Chess.UCI.exact))\n\"-0.9\"","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Mate in N scores are displayed as #N:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> scorestring(Score(6, true, Chess.UCI.exact))\n\"+#6\"","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"UCI chess engines always output scores from the point of view of the current side to move. This is not always what we want; often we want scores from white's point of view (i.e. positive scores mean that white is better, while negative scores mean that black is better). scorestring takes an optional named parameter invertsign that can be used to invert the sign:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> scorestring(Score(-140, false, Chess.UCI.exact), invertsign=true)\n\"+1.4\"","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"The other interesting slot of SearchInfo is the pv. This is a vector of moves, what the engine considers the best line of play, assuming optimal play from both sides.","category":"page"},{"location":"manual/#Example:-Engine-vs-Engine-Games-1","page":"Tutorial","title":"Example: Engine vs Engine Games","text":"","category":"section"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Using what we have learned, we can easily make a function that generates engine vs engine games. Let's use the random_opening function we wrote earlier (in the section about opening books) to initialize the game with some opening position, and let the engine play out the game from there. We'll let the engine think 10 thousand nodes per move.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"function engine_game(engine)\n    g = random_opening()\n    while !isterminal(g)\n        setboard(engine, g)\n        move = search(engine, \"go nodes 10000\").bestmove\n        domove!(g, move)\n    end\n    g\nend","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Let's try generating a game using Stockfish:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> engine_game(sf)\nGame:\n 1. d4 d5 2. e3 Bf5 3. Bd3 Bxd3 4. Qxd3 c6 5. Nf3 e6 6. Nbd2 Nf6 7. O-O c5 8. dxc5 Nbd7 9. b4 a5 10. c3 Be7 11. h3 O-O 12. e4 Qc7 13. a4 Rfd8 14. Nd4 Ne5 15. Qe3 Ng6 16. Nb5 Qb8 17. Bb2 dxe4 18. Nxe4 Nd5 19. Qe1 h6 20. Ned6 Bf6 21. Rb1 Be7 22. c4 Ndf4 23. g3 Nxh3+ 24. Kg2 Ng5 25. f4 Nh7 26. bxa5 Bxd6 27. cxd6 Rxd6 28. Nxd6 Qxd6 29. Qe4 Qd2+ 30. Rf2 Qxa5 31. f5 exf5 32. Rxf5 Qd2+ 33. Rf2 Qd7 34. Qd5 Qe8 35. Re1 Qf8 36. c5 Ng5 37. Bc1 Rxa4 38. Bxg5 hxg5 39. Qxb7 Qxc5 40. Qxf7+ Kh7 41. Qf3 Rh4 42. Rfe2 Kh6 43. Re6 Qc2+ 44. R1e2 Qxe2+ 45. Qxe2 Kh7 46. Rxg6 Rb4 47. Rxg5 Rh4 48. Qe7 Rh2+ 49. Kxh2 Kh8 50. Qxg7# *","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"Let's try to make a slightly more sophisticated version of this function, that also includes the engine evaluation for each move as a comment in the game.","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"In our improved engine vs engine function, we need to supply an infoaction in the call to search, in order to obtain the engine evaluation. It can be done like this:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"function engine_vs_engine_with_evals(engine)\n    # A variable for keeping track of the score:\n    score = Score(0, true, Chess.UCI.exact)\n\n    # An infoaction function that updates the score:\n    function infoaction(infoline)\n        info = parsesearchinfo(infoline)\n        if !isnothing(info.score)\n            score = info.score\n        end\n    end\n\n    g = random_opening()\n    while !isterminal(g)\n        whitetomove = sidetomove(board(g)) == WHITE\n        setboard(engine, g)\n        # Use the infoaction defined above when calling search:\n        move = search(engine, \"go nodes 10000\", infoaction=infoaction).bestmove\n        # Add the move to the game:\n        domove!(g, move)\n        # Add the score as a comment:\n        addcomment!(g, scorestring(score, invertsign=!whitetomove))\n    end\n    g\nend","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"A test game:","category":"page"},{"location":"manual/#","page":"Tutorial","title":"Tutorial","text":"julia> engine_vs_engine_with_evals(sf)\nGame:\n 1. d4 Nf6 2. c4 c5 3. d5 b5 4. b3 bxc4 5. bxc4 g6 6. Bb2 Bg7 7. Nd2 {-0.1} d6 {-0.1} 8. e4 {+0.0} Nbd7 {+0.2} 9. Be2 {+0.1} O-O {+0.2} 10. Qc2 {+0.0} Rb8 {-0.3} 11. Bc3 {+0.1} Ne8 {+0.2} 12. Ngf3 {+0.2} Bxc3 {+0.1} 13. Qxc3 {+0.3} Ng7 {+0.1} 14. O-O {+0.2} e5 {+0.4} 15. Rfb1 {+0.4} Rb6 {+0.5} 16. Rxb6 {+0.6} Qxb6 {+0.6} 17. Rb1 {+0.4} Qc7 {+0.4} 18. Rb5 {+0.3} a6 {+0.6} 19. Rb3 {+0.7} f5 {+0.7} 20. Qc2 {+0.4} Nf6 {+0.2} 21. Bd3 {+0.6} Nfh5 {+0.6} 22. Qb2 {+0.8} Ne8 {+0.6} 23. Rb8 {+1.2} Nf4 {+0.8} 24. Bf1 {+1.2} Nf6 {+1.0} 25. g3 {+1.2} N4h5 {+1.3} 26. exf5 {+1.1} Nd7 {+1.1} 27. Rxc8 {+2.1} Rxc8 {+1.6} 28. fxg6 {+1.4} hxg6 {+1.2} 29. Ng5 {+1.5} Rb8 {+1.3} 30. Qa3 {+1.5} Nhf6 {+1.6} 31. Ne6 {+1.5} Qb7 {+1.1} 32. Qf3 {+0.8} Qb4 {+0.6} 33. Qe3 {+2.4} Nf8 {+1.0} 34. Qg5 {+0.6} Kf7 {+0.4} 35. Bh3 {+1.9} Re8 {+1.4} 36. Bf5 {+3.3} Nxe6 {+4.8} 37. Qxg6+ {+8.2} Ke7 {+9.0} 38. dxe6 {+8.9} d5 {+9.3} 39. Qf7+ {+9.8} Kd6 {+9.5} 40. Qxf6 {+10.0} Qxd2 {+10.8} 41. e7+ {+10.9} Kc7 {+11.2} 42. Qxe5+ {+11.6} Kb7 {+11.8} 43. cxd5 {+11.6} Qc3 {+11.1} 44. Qxc3 {+13.4} Kb6 {+13.5} 45. d6 {+32.0} Kb5 {+34.0} 46. Bd7+ {+#6} Kb6 {+#5} 47. Bxe8 {+#5} c4 {+#3} 48. Qb4+ {+#3} Ka7 {+#2} 49. Bc6 {+#2} c3 {+#1} 50. Qb7# {+#1} *","category":"page"},{"location":"#Chess.jl-1","page":"Home","title":"Chess.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia chess programming library.","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package contains various utilities for computer chess programming. There are functions for creating and manipulating chess games, chess positions and sets of squares on the board, for reading and writing chess games in the popular PGN format (including support for comments and variations), for creating opening trees, and for interacting with UCI chess engines.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The library was designed for the purpose of doing machine learning experiments in computer chess, but it should also be suitable for most other types of chess software.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Chess.jl can be installed from the package manager at Julia's REPL:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(@v1.6) pkg> add Chess","category":"page"}]
}
